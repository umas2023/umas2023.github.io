<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-04T20:52:11+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">leetcode: 9键输入法组合</title><link href="/leetcode/python/9_button_input/" rel="alternate" type="text/html" title="leetcode: 9键输入法组合" /><published>2023-10-04T20:42:31+08:00</published><updated>2023-10-04T20:42:31+08:00</updated><id>/leetcode/python/9_button_input</id><content type="html" xml:base="/leetcode/python/9_button_input/"><![CDATA[<ul>
  <li>Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题</li>
  <li>简述一下题目大意：9键输入法，给定按键序列，返回所有组合</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>比如按下23
所有可能的组合有['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
</code></pre></div></div>

<ul>
  <li>题目本身不难，循环嵌套再拼接就行了</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dic9</span><span class="o">=</span><span class="p">{</span>
        <span class="sh">"</span><span class="s">2</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">g</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">h</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">i</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">5</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">j</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">k</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">l</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">6</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">m</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">7</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">q</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">8</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">u</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">v</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">9</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">z</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">dic9</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">dic9</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">sv</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">letter</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">sv</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>（但是他妈的，python打印字符串列表时默认使用单引号，牛客判定结果用双引号，我的程序通过率是0%）</li>
  <li>（↑转义成纯字符串也通不过，妈的真是触及到知识盲区了）</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-04-9_button_input/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题 简述一下题目大意：9键输入法，给定按键序列，返回所有组合]]></summary></entry><entry><title type="html">leetcode: 不同路径</title><link href="/leetcode/python/uniquePaths/" rel="alternate" type="text/html" title="leetcode: 不同路径" /><published>2023-10-04T19:19:58+08:00</published><updated>2023-10-04T19:19:58+08:00</updated><id>/leetcode/python/uniquePaths</id><content type="html" xml:base="/leetcode/python/uniquePaths/"><![CDATA[<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？</p>
  </li>
  <li>
    <p>自解（动态规划）：易知dp[i][j] = dp[i-1][j] + dp[i][j-1]，边界是当i或j=1时dp[i][j]=1</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">j</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">uniquePaths</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

</code></pre></div></div>

<ul>
  <li>（因为最近在刷动态规划，双眼被蒙蔽了）</li>
  <li>想要走到右下角，总步数是固定的m+n-2，向右几步和向下几步也都是固定的，向下m-1次，向右n-1次；所以路径总是就是从m+n-2次移动中选择m-1次向下移动的方案数，即组合数：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C(m-1)(m+n-2) = (m+n-2)! / (m-1)!(n-1)!
</code></pre></div></div>

<ul>
  <li>一行公式就可以解决</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-04-uniquePaths/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[链接：https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&amp;envId=dynamic-programming]]></summary></entry><entry><title type="html">leetcode: 打家劫舍</title><link href="/leetcode/python/rob/" rel="alternate" type="text/html" title="leetcode: 打家劫舍" /><published>2023-10-04T16:33:58+08:00</published><updated>2023-10-04T16:33:58+08:00</updated><id>/leetcode/python/rob</id><content type="html" xml:base="/leetcode/python/rob/"><![CDATA[<h2 id="打家劫舍">打家劫舍</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre></div></div>

<ul>
  <li>首先看边界，只有一间房屋时，dp[0] = List[0]；两间房屋时dp[1] = max(List)</li>
  <li>接下来考虑递推关系。这道题很像之前的青蛙跳阶问题，在青蛙跳阶中，跳到第10级有2种方法：9+1或8+2；在这一题中，小偷偷10家也有2种方法：偷前9家或8+1，收益最大的方法即为解，所以状态转移方程：dp[n] = max( dp[n-1], dp[n-2]+List[n] )</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">len_s</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">len_s</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len_s</span><span class="p">]</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">rob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>

</code></pre></div></div>

<ul>
  <li>注意因为向前追溯了2位到dp[i-2]，所以dp的长度增加了1位，即(len_s+1)而不是len_s，i需要从2开始循环</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-04-rob/image_1.jpg) -->

<h2 id="打家劫舍plus---删除并获得点数">打家劫舍plus - 删除并获得点数</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/delete-and-earn/description/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：给你一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素（这些元素被删除后不获得点数）。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
</code></pre></div></div>

<ul>
  <li>下面解释一下为什么这道题是打家劫舍plus</li>
  <li>每次选择后都删除了所有nums[i] - 1 和 nums[i] + 1，可以理解为失去了点数sum([x for x in nums if x == nums[i] ± 1])</li>
  <li>考虑存在多个nums[i]的情况，因为第一次选择完之后已经删除了所有满足条件的元素，所有nums[i]可以重复选择直至全部选中，也就是说选择nums[i]相当于获得了点数sum([x for x in nums if x == nums[i]])</li>
  <li>影响最终结果的是所有相同元素的和，而不是单个的元素，因此可以以nums[i]为key，以sum([x for x in nums if x == nums[i]])为value构建新的数组，示例如下</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; [0,1,2,3,3]
&lt;&lt;&lt; [0,1,2,6]
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; [2, 2, 3, 3, 3, 4]
&lt;&lt;&lt; [0, 0, 4, 9, 4]
</code></pre></div></div>

<ul>
  <li>这时删除了所有nums[i] - 1 和 nums[i] + 1即意味着在新数组中无法选中相邻数字，也就是“相邻房屋会报警”</li>
  <li>（看到这里不得不甘拜下风）</li>
</ul>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[打家劫舍]]></summary></entry><entry><title type="html">leetcode: 斐波那契数列</title><link href="/leetcode/python/fib/" rel="alternate" type="text/html" title="leetcode: 斐波那契数列" /><published>2023-10-04T16:22:28+08:00</published><updated>2023-10-04T16:22:28+08:00</updated><id>/leetcode/python/fib</id><content type="html" xml:base="/leetcode/python/fib/"><![CDATA[<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/fibonacci-number/description/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>题目就是给n求fib(n)</li>
  <li>可以用动态规划的方法来理解</li>
  <li>边界条件是dp(0) = 0, dp(1) = 1</li>
  <li>
    <p>状态转移方程是 dp(n) = dp(n-1)+dp(n-2)</p>
  </li>
  <li>为了节省空间，可以用p、q、r仅保留dp的后三位，滚动赋值</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-10-04-fib/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="nf">fib</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nb">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nf">for </span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> 
            <span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> 
            <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[链接：https://leetcode.cn/problems/fibonacci-number/description/?envType=study-plan-v2&amp;envId=dynamic-programming]]></summary></entry><entry><title type="html">leetcode: 正则表达式匹配</title><link href="/leetcode/python/isMatch/" rel="alternate" type="text/html" title="leetcode: 正则表达式匹配" /><published>2023-10-04T15:11:51+08:00</published><updated>2023-10-04T15:11:51+08:00</updated><id>/leetcode/python/isMatch</id><content type="html" xml:base="/leetcode/python/isMatch/"><![CDATA[<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/regular-expression-matching/</p>
  </li>
  <li>
    <p>题目：</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给你一个字符串 s （string）和一个字符规律 p（pattern），请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
</code></pre></div></div>

<ul>
  <li>示例</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。


Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
</code></pre></div></div>

<ul>
  <li>
    <p>初见没有正确率理解题意中的匹配0次，从第二个示例可以看出包含’*‘前面的字母c在内都可以不被匹配，也就是说’*‘和前面的字母必须被看作一个整体</p>
  </li>
  <li>
    <p>字母和’.’的情况不多赘述，主要讨论’*‘的情况</p>
  </li>
  <li>
    <p>dp矩阵dp[i][j]表示s的前i个字符可以和p的前j个字符匹配，关键问题是如何构造状态转移方程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了1次
                        i     
                        ↓       
s[i]    a       a       a       b
p[j]    a       a       a       *       b
                                ↑
                                j
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了0次
                        i
                        ↓
s[i]    a       a       b
p[j]    a       a       a       *       b
                                ↑
                                j
</code></pre></div></div>

<ul>
  <li>将星号（p[j]）和前一个字母（p[j-1]）视为整体，进行匹配时有2种情况：
    <ul>
      <li>目标字母（s[i]）和模板字母（p[j-1]）不同，即【字母+星号】匹配了0次，此时能否匹配取决于【字母+星号】前一位，即p[j-2]，判断s[i] ?= p[j-2]，如果前一位匹配，即dp[i][j-2]=True，则dp[i][j]=True</li>
      <li>目标字母（s[i]）和模板字母（p[j-1]）相同，这里又分为两种情况：
        <ul>
          <li>1.虽然相同但s[i]匹配的实际上是星号后面的内容，即此处的【字母+星号】依然匹配了0次（下面图示的状态，这里i处的a实际上应该匹配j+1处的a），这种情况和上面的情况属于同一种情况，为了处理它，可以把这里的计算结果与上面计算的dp[i][j-2]进行与运算，这就是为什么题解中使用了|=而不是直接赋值
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了0次
              i
              ↓
s[i]    a       a       b
p[j]    a       a       *       a       b
                      ↑
                      j
</code></pre></div>            </div>
          </li>
          <li>2.相同且确实匹配，此时【字母+星号】匹配了1次或多次，为了找到所有可能的匹配，需要向前追溯目标字符串，即s[i-1]，判断s[i-1] ?= p[j]。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>上述所有情况中只要有一条成立，就可以判断匹配成功，所以程序中始终在用<code class="language-plaintext highlighter-rouge">|=</code>更新dp[i][j]的值</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-10-04-isMatch/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span><span class="n">p</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>



<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">isMatch</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="sh">'</span><span class="s">aab</span><span class="sh">'</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="sh">'</span><span class="s">aaa*b</span><span class="sh">'</span><span class="p">))</span>

</code></pre></div></div>

<ul>
  <li>好的，虽然尽力理解了这么多，但其实还是没有完全理解，不愧是困难题，（这题跳过）</li>
</ul>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[链接：https://leetcode.cn/problems/regular-expression-matching/]]></summary></entry><entry><title type="html">python: 创建矩阵</title><link href="/python/matrix/" rel="alternate" type="text/html" title="python: 创建矩阵" /><published>2023-10-03T20:05:30+08:00</published><updated>2023-10-03T20:05:30+08:00</updated><id>/python/matrix</id><content type="html" xml:base="/python/matrix/"><![CDATA[<ul>
  <li>使用列表乘法可以快速初始化一个列表</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="c1"># [0, 0, 0]
</span></code></pre></div></div>

<ul>
  <li>那么嵌套一层之后就可以创建矩阵了吗</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="c1"># [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
</span></code></pre></div></div>

<ul>
  <li>上面的代码看似合理，但为矩阵赋值时就会发现问题</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="nf">print</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
<span class="c1"># [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
</span></code></pre></div></div>

<ul>
  <li>
    <p>执行dp = [[0] * 3] * 3时，实际上创建了一个包含3个相同引用的列表，它们指向同一个内存地址。修改其中一个元素的值时，其他所有引用也会随之改变。</p>
  </li>
  <li>
    <p>可以用列表推导式来创建矩阵</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nf">print</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>或者numpy</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<!-- ![引入图片](/image/python/2023-10-03-matrix/image_1.jpg) -->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[使用列表乘法可以快速初始化一个列表]]></summary></entry><entry><title type="html">leetcode: dp-最长回文子串</title><link href="/leetcode/python/longestPalindrome/" rel="alternate" type="text/html" title="leetcode: dp-最长回文子串" /><published>2023-10-03T17:38:37+08:00</published><updated>2023-10-03T17:38:37+08:00</updated><id>/leetcode/python/longestPalindrome</id><content type="html" xml:base="/leetcode/python/longestPalindrome/"><![CDATA[<ul>
  <li>
    <p>原题链接：https://leetcode.cn/problems/longest-palindromic-substring/</p>
  </li>
  <li>
    <p>题目：</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给你一个字符串 s，找到 s 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

示例 1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：
输入：s = "cbbd"
输出："bb"
</code></pre></div></div>

<ul>
  <li>边界：字符串长度为1，是回文串；字符串长度为2，若两字符相对，则为回文串</li>
  <li>
    <p>递推：判断s(i,j)为回文串的两个条件：首先s[i]=s[j]；其次s(i+1,j-1)是回文串</p>
  </li>
  <li>用db[i,j]:bool来表示s(i,j)是否为回文串</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="sh">''</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lens</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">lens</span><span class="p">)]</span>
        <span class="c1"># 字串长度
</span>        <span class="k">for</span> <span class="n">sub_len</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">lens</span><span class="p">):</span>
            <span class="c1"># 起点
</span>            <span class="k">for</span> <span class="n">sub_start</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">lens</span> <span class="o">-</span> <span class="n">sub_len</span><span class="p">):</span>
                <span class="n">sub_end</span> <span class="o">=</span> <span class="n">sub_start</span> <span class="o">+</span> <span class="n">sub_len</span>
                <span class="c1"># 边界
</span>                <span class="k">if</span> <span class="n">sub_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">sub_len</span><span class="p">][</span><span class="n">sub_start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">sub_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">sub_len</span><span class="p">][</span><span class="n">sub_start</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">sub_start</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">sub_end</span><span class="p">])</span>

                <span class="c1"># 递推
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">sub_len</span><span class="p">][</span><span class="n">sub_start</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">sub_start</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">sub_end</span><span class="p">]</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub_len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">][</span><span class="n">sub_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># 回文字串长度
</span>                <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">sub_len</span><span class="p">][</span><span class="n">sub_start</span><span class="p">]</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sub_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">sub_start</span><span class="p">:</span><span class="n">sub_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ans</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">longestPalindrome</span><span class="p">(</span><span class="sh">"</span><span class="s">abac</span><span class="sh">"</span><span class="p">))</span>


</code></pre></div></div>

<!-- ![引入图片](/image/leetcode/2023-10-03-longestPalindrome/image_1.jpg) -->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[原题链接：https://leetcode.cn/problems/longest-palindromic-substring/]]></summary></entry><entry><title type="html">leetcode: dp-递增子序列问题</title><link href="/leetcode/python/inc_sublist/" rel="alternate" type="text/html" title="leetcode: dp-递增子序列问题" /><published>2023-09-27T19:41:57+08:00</published><updated>2023-09-27T19:41:57+08:00</updated><id>/leetcode/python/inc_sublist</id><content type="html" xml:base="/leetcode/python/inc_sublist/"><![CDATA[<h2 id="问题">问题</h2>

<ul>
  <li>接前篇青蛙跳阶问题，补充一个动态规划更有代表性的例子：递增子序列问题</li>
  <li>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [0,1,0,3,2,3]
输出：4 
解释：[0,1,2,3]不一定必须是连续子序列
</code></pre></div></div>

<h2 id="规律">规律</h2>

<ul>
  <li>首先遵循自底向上原则枚举分析分析规律：</li>
  <li>如果新加入一个元素nums[i], 最长递增子序列要么是以nums[i]结尾的递增子序列，要么就是nums[i-1]的最长递增子序列。</li>
  <li>对于一个以nums[i]结尾的数组nums，如果存在j属于区间[0，i-1],并且num[i]&gt;num[j]的话，则有，dp(i) =max(dp(j))+1，</li>
</ul>

<h2 id="边界">边界</h2>

<ul>
  <li>当nums数组只有一个元素时，最长递增子序列的长度dp(1)=1,当nums数组有两个元素时，dp(2) =2或者1， 因此边界就是dp(1)=1。</li>
</ul>

<h2 id="最优子结构">最优子结构</h2>

<ul>
  <li>dp(i) =max(dp(j))+1，存在j属于区间[0，i-1],并且num[i]&gt;num[j]。</li>
  <li>max(dp(j)) 就是最优子结构。</li>
</ul>

<h2 id="代码">代码</h2>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lengthOfList</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="c1"># 使用长度为nums长度的列表进行初始化
</span>    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>


<span class="nf">print</span><span class="p">(</span><span class="nf">lengthOfList</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<!-- ![引入图片](/image/leetcode/2023-09-27-inc_sublist/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[问题]]></summary></entry><entry><title type="html">leetcode: dp-青蛙跳阶问题</title><link href="/leetcode/python/jumpFrog/" rel="alternate" type="text/html" title="leetcode: dp-青蛙跳阶问题" /><published>2023-09-27T18:59:41+08:00</published><updated>2023-09-27T18:59:41+08:00</updated><id>/leetcode/python/jumpFrog</id><content type="html" xml:base="/leetcode/python/jumpFrog/"><![CDATA[<ul>
  <li>
    <p>问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法</p>
  </li>
  <li>倒推跳到10级有2种方法：9级+1或8级+1，即通用公式为：f(n) = f(n-1) + f(n-2)</li>
  <li>可以很简单的递归出结果</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">numWays</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>递归树的总节点数为2^n+1，即时间复杂度为O(2^n)</li>
  <li>以10为例，分析上面的代码发现，计算f(10)时拆分出了f(9)和f(8)，而计算f(9)时拆分出了f(8)和f(7)，此时f(8)已经被计算了2次，同理有很多节点被重复计算了</li>
  <li>因此可以通过一个哈希表作为备忘录，记录已经计算过的节点，修改后的程序如下</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HashMap</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">HashMap</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">HashMap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">HashMap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">HashMap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">numWays</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

</code></pre></div></div>

<ul>
  <li>动态规划的解法从底向上，这个问题中边界是f(1) = 1, f(2) = 2；最优子结构是f(n-1)和f(n-2)；状态转移方程是f(n)= f（n-1）+f（n-2）</li>
  <li>可以发现，f（n）只依赖前面两个数，所以只需要两个变量a和b来存储，就可以满足需求了
    <ul>
      <li>关于最优子结构：一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质</li>
    </ul>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">numWays</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">next</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="nf">print</span><span class="p">(</span><span class="nf">numWays</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>动态规划问题的框架</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][...]</span> <span class="o">=</span> <span class="n">边界值</span>
<span class="nf">for</span><span class="p">(</span><span class="n">状态1</span> <span class="err">：</span><span class="n">所有状态1的值</span><span class="p">){</span>
    <span class="nf">for</span><span class="p">(</span><span class="n">状态2</span> <span class="err">：</span><span class="n">所有状态2的值</span><span class="p">){</span>
        <span class="nf">for</span><span class="p">(...){</span>
          <span class="o">//</span><span class="n">状态转移方程</span>
          <span class="n">dp</span><span class="p">[</span><span class="n">状态1</span><span class="p">][</span><span class="n">状态2</span><span class="p">][...]</span> <span class="o">=</span> <span class="n">求最值</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>其中外层for循环用来遍历f(n)，内层for循环用状态转移方程来确定最优子结构，青蛙例子中因为状态转移方程是简单的f(n)= f（n-1）+f（n-2）所以只用了一层循环</li>
  <li>一个关于递增子序列的经典例题参见下一篇</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-09-27-jumpFrog/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<ul>
  <li>补充原题链接：https://leetcode.cn/problems/climbing-stairs/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法]]></summary></entry><entry><title type="html">leetcode: 递归-相同的树</title><link href="/leetcode/python/isSameTree/" rel="alternate" type="text/html" title="leetcode: 递归-相同的树" /><published>2023-09-27T18:13:17+08:00</published><updated>2023-09-27T18:13:17+08:00</updated><id>/leetcode/python/isSameTree</id><content type="html" xml:base="/leetcode/python/isSameTree/"><![CDATA[<h1 id="leetcode-100相同的树">leetcode 100.相同的树</h1>

<ul>
  <li>
    <p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
  </li>
  <li>
    <p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
  </li>
  <li>输入：p = [1,2,3], q = [1,2,3]</li>
  <li>输出：true</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-09-27-isSameTree/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 两者都为None则返回True
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="c1"># 其中一个为None则返回False
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># 都不为None则比较值
</span>        <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># 对左右子树分别进行递归比较
</span>        <span class="k">return</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[leetcode 100.相同的树]]></summary></entry></feed>