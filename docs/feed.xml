<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-03T16:16:57+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">leetcode: 理想复活赛笔试</title><link href="/leetcode/python/js/lixiang/" rel="alternate" type="text/html" title="leetcode: 理想复活赛笔试" /><published>2023-11-03T15:28:17+08:00</published><updated>2023-11-03T15:28:17+08:00</updated><id>/leetcode/python/js/lixiang</id><content type="html" xml:base="/leetcode/python/js/lixiang/"><![CDATA[<ul>
  <li>虽然被捞起来打复活赛，但明显这个部门需要的不是我，选择题基本没有会的，算法两个c的内存调度也没写</li>
  <li>只记录两道py</li>
</ul>

<h2 id="知识总结">知识总结</h2>

<ul>
  <li>最小堆</li>
  <li>DFS/BFS</li>
</ul>

<h2 id="返回数组第k大">返回数组第k大</h2>

<ul>
  <li>提交的代码显然不是考官希望看到的</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">)[</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">findKthLargest</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>这里补充一个之前准备前端面试时候的解法（js），构建一个最小堆</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 找出数组中第k大的元素，用堆实现</span>

<span class="c1">// 遍历数组 nums 中的每个元素，并将其插入到最小堆中。如果堆的大小超过了 k，则移除堆顶元素，以确保堆的大小不超过 k。</span>
<span class="c1">//最后，我们返回堆顶元素，即为数组中第 k 大的元素。</span>
<span class="kd">function</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建一个最小堆</span>
    <span class="kd">const</span> <span class="nx">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MinHeap</span><span class="p">();</span>
    <span class="c1">// 将数组元素插入最小堆</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">minHeap</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="c1">// 如果堆的大小超过 k，则移除堆顶元素</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">minHeap</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">minHeap</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 返回堆顶元素，即为第 k 大元素</span>
    <span class="k">return</span> <span class="nx">minHeap</span><span class="p">.</span><span class="nf">peek</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 最小堆类定义</span>
<span class="c1">// 最小堆（Min Heap）是一种二叉堆，它是一种特殊的完全二叉树结构，其中每个父节点的值都小于或等于其子节点的值。换句话说，最小堆中的最小值存储在根节点，并且对于堆中的任意节点，其值都小于或等于其子节点的值。</span>
<span class="c1">// 索引为 i 的节点的父节点索引为 (i - 1) / 2，左子节点索引为 2 * i + 1，右子节点索引为 2 * i + 2。</span>
<span class="kd">class</span> <span class="nc">MinHeap</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="c1">// 获取堆的大小</span>
    <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 获取堆顶元素</span>
    <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 插入元素到堆中</span>
    <span class="nf">insert</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nf">heapifyUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 移除堆顶元素</span>
    <span class="nf">remove</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">removedValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">lastValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lastValue</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyDown</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">removedValue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将元素上移，保持堆的性质(插入元素时)</span>
    <span class="nf">heapifyUp</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">parentIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
            <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]];</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 将元素下移，保持堆的性质（删除元素时）</span>
    <span class="nf">heapifyDown</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">leftChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">rightChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">leftChildIndex</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">leftChildIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">leftChildIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">rightChildIndex</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">rightChildIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">rightChildIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">smallestChildIndex</span> <span class="o">!==</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]];</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyDown</span><span class="p">(</span><span class="nx">smallestChildIndex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">kthLargest</span> <span class="o">=</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">kthLargest</span><span class="p">);</span> <span class="c1">// 输出 6</span>

</code></pre></div></div>

<h2 id="01岛屿连接">01岛屿连接</h2>

<ul>
  <li>
    <p>这题前面某一家前端面试时候问到过，但实际用代码实现之后因为超时没能100%</p>
  </li>
  <li>思路是首先遍历每一项，通过一个check4p子函数迭代检查当前位置的4个方向</li>
  <li>为了防止重复遍历，在子函数中计数过的1都改成2（面试时候面试官提到改成0可能会影响后续的遍历，但现在想想好像也没关系，官方题解给的也是0）</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 最大全1区域
# 求01矩阵中最大的全1连通块的大小
# [[1,1,1,0],[1,1,0,1],[1,0,0,1],[1,1,0,0]]
# 通过率60%，超时
</span>

<span class="c1">#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
#
# @param grid int整型二维数组
# @return int整型
#
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">cur_size</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">):</span>
            <span class="sh">"""</span><span class="s">迭代检查四个方向</span><span class="sh">"""</span>
            <span class="k">global</span> <span class="n">cur_size</span>

            <span class="nf">if </span><span class="p">(</span>
                <span class="p">(</span><span class="n">pos_x</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_y</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> 
            <span class="nf">if </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cur_size</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nf">check4p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">max_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">cur_size</span><span class="p">)</span>
                    <span class="n">cur_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">max_size</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">solve</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>

</code></pre></div></div>

<ul>
  <li>笔试时候比较紧张，写法可能不够优雅（global），贴一个gpt的答案</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_largest_ones_block</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">cols</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="ow">or</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">max_size</span>


<span class="c1"># 示例输入
</span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="c1"># 调用函数计算最大全1连通块的大小
</span><span class="n">largest_block_size</span> <span class="o">=</span> <span class="nf">find_largest_ones_block</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">最大全1连通块的大小为:</span><span class="sh">"</span><span class="p">,</span> <span class="n">largest_block_size</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>力扣200：岛屿数量，这题是求连通块的数量，不是最大连通块的大小；https://leetcode.cn/problems/number-of-islands/</li>
  <li>力扣827：最大人工岛，把一个0变成1之后求最大岛屿面积，是本题的进阶版；https://leetcode.cn/problems/making-a-large-island/</li>
  <li>
    <p>力扣695，找到了，是这一题，自解在力扣上是能够通过的，力扣官方题解也并没有提到复杂度更低的算法，可能理想还有其他的解法；https://leetcode.cn/problems/max-area-of-island/</p>
  </li>
  <li>补充知识：深度优先搜索（DFS）</li>
</ul>

<p>DFS（深度优先搜索）是一种用于遍历或搜索图形和树等数据结构的算法。它从一个起始节点开始，沿着路径尽可能深入地探索，直到达到无法继续或者满足特定条件的节点为止，然后回溯并继续探索其他路径。</p>

<ul>
  <li>深度和广度优先搜索(DFS/BFS)</li>
</ul>

<p>DFS（深度优先搜索）和BFS（广度优先搜索）是两种常见的图遍历算法，它们在搜索策略和遍历顺序上有所不同。</p>

<p>搜索策略：</p>

<p>DFS：DFS采用深度优先的搜索策略，即从起始节点开始，沿着路径尽可能深入地探索，直到达到无法继续或满足特定条件的节点为止，然后回溯并继续探索其他路径。DFS通过递归或使用栈来实现。
BFS：BFS采用广度优先的搜索策略，即从起始节点开始，逐层地遍历节点，先访问离起始节点最近的节点，然后依次访问离起始节点逐渐远的节点。BFS使用队列来存储待访问的节点，先进先出的原则确保了按层遍历。</p>

<p>遍历顺序：</p>

<p>DFS：DFS在遍历过程中沿着一个路径尽可能深入，直到达到叶子节点或无法继续探索的节点。因此，DFS的遍历顺序是深度方向上的，先访问最新加入栈的节点。
BFS：BFS在遍历过程中按层遍历，先访问当前层的节点，然后再访问下一层的节点。因此，BFS的遍历顺序是广度方向上的，先访问离起始节点最近的节点。</p>

<ul>
  <li>矩阵可能不能很好的区分深度和广度（事实上上面的题目也可以用两种方法（用栈还是队列存储）），用二叉树就很容易理解区别了</li>
</ul>

<!--![引入图片](/image/leetcode/2023-11-03-lixiang/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><category term="js" /><summary type="html"><![CDATA[虽然被捞起来打复活赛，但明显这个部门需要的不是我，选择题基本没有会的，算法两个c的内存调度也没写 只记录两道py]]></summary></entry><entry><title type="html">leetcode: 宇量昇复活赛笔试</title><link href="/leetcode/python/yuliangsheng/" rel="alternate" type="text/html" title="leetcode: 宇量昇复活赛笔试" /><published>2023-11-03T15:16:29+08:00</published><updated>2023-11-03T15:16:29+08:00</updated><id>/leetcode/python/yuliangsheng</id><content type="html" xml:base="/leetcode/python/yuliangsheng/"><![CDATA[<ul>
  <li>没想到面试挂了之被另一个hr捞起来打复活赛了</li>
</ul>

<h2 id="知识总结">知识总结</h2>

<ul>
  <li>（快乐数）小技巧：py不能直接遍历int数字的每一位，但用str转化为字符串就可以直接用for遍历了</li>
</ul>

<h2 id="快乐数">快乐数</h2>

<ul>
  <li>快乐数：每一位的平方相加和，迭代等于1</li>
  <li>19 -&gt; 82 -&gt; 68 -&gt; 100 -&gt; true</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">happynum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">recordList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">iterfunc</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">recordList</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">recordList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">next_n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="nf">str</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                <span class="n">next_n</span> <span class="o">+=</span> <span class="nf">int</span><span class="p">(</span><span class="n">each</span><span class="p">)</span> <span class="o">*</span> <span class="nf">int</span><span class="p">(</span><span class="n">each</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">next_n</span><span class="p">,</span><span class="n">recordList</span><span class="p">)</span>
            <span class="k">return</span> <span class="nf">iterfunc</span><span class="p">(</span><span class="n">next_n</span><span class="p">)</span>

        <span class="k">return</span> <span class="nf">iterfunc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">happynum</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="消消乐">消消乐</h2>

<ul>
  <li>消消乐，消除字符串相邻相同的字符，迭代</li>
  <li>bcaac -&gt; bcc -&gt; b</li>
  <li>
    <p>自解通过率只有20%</p>
  </li>
  <li>思路是先把字符串转为数组，把所有符合条件的项改为True，然后一次性删除，再迭代</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">removeDuplicatesList</span><span class="p">(</span><span class="n">str_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>

            <span class="c1"># print("start:", str_list)
</span>
            <span class="n">same_str</span> <span class="o">=</span> <span class="sh">""</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">str_list</span><span class="p">)):</span>
                <span class="n">this_str</span> <span class="o">=</span> <span class="n">str_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">next_str</span> <span class="o">=</span> <span class="bp">False</span> <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">str_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">str_list</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">this_str</span> <span class="o">==</span> <span class="n">next_str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">this_str</span> <span class="o">==</span> <span class="n">same_str</span><span class="p">):</span>
                    <span class="n">str_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">same_str</span> <span class="o">=</span> <span class="n">this_str</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">same_str</span> <span class="o">=</span> <span class="sh">""</span>

            <span class="c1"># print(str_list)
</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">True</span> <span class="ow">in</span> <span class="n">str_list</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">str_list</span>
            <span class="k">return</span> <span class="nf">removeDuplicatesList</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">str_list</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">True</span><span class="p">])</span>

        <span class="k">return</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">removeDuplicatesList</span><span class="p">(</span><span class="n">sl</span><span class="p">))</span>


<span class="c1"># print(Solution().removeDuplicates("bcaac") == "b")
# print(Solution().removeDuplicates("aaaaa") == "")
# print(Solution().removeDuplicates("bbab") == "ab")
</span><span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">removeDuplicates</span><span class="p">(</span><span class="sh">"</span><span class="s">bba</span><span class="sh">"</span><span class="p">))</span> 

</code></pre></div></div>

<ul>
  <li>力扣1047，删除字符串中的所有相邻重复项</li>
  <li>根据力扣的判题结果显示，aaaaaaaaa输出应该是a而不是空字符串，是我理解错题意了</li>
  <li>力扣题目中明确提到每次操作删除相邻两个项，也就是说奇数的重复项会留下一项，宇量昇笔试题目描述不清楚，自解直接删除了所有连通的相同项</li>
</ul>

<h2 id="正则匹配">正则匹配</h2>

<ul>
  <li>碰到原题了，参见力扣10：https://leetcode.cn/problems/regular-expression-matching/</li>
  <li>但很离谱的是按照答案提交通过率只有74.29%，应该没有哪里写错</li>
</ul>

<!--![引入图片](/image/leetcode/2023-11-03-yuliangsheng/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[没想到面试挂了之被另一个hr捞起来打复活赛了]]></summary></entry><entry><title type="html">js: 正则表达式</title><link href="/js/knowhow/regular_expression/" rel="alternate" type="text/html" title="js: 正则表达式" /><published>2023-10-23T13:18:39+08:00</published><updated>2023-10-23T13:18:39+08:00</updated><id>/js/knowhow/regular_expression</id><content type="html" xml:base="/js/knowhow/regular_expression/"><![CDATA[<ul>
  <li>
    <p>头尾两个斜杠 // 通常用于包裹正则表达式的模式，用来标识正则表达式的开始和结束</p>
  </li>
  <li>
    <p>常用的特殊字符转义序列</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\w：匹配包括字母、数字和下划线的任何单词字符（相当于 [a-zA-Z0-9_]）。

\W：匹配任何非单词字符（相当于 [^a-zA-Z0-9_]）。

\b：匹配单词边界，即单词和非单词字符之间的位置。

\B：匹配非单词边界。

\d：匹配任何数字字符（相当于 [0-9]）。

\D：匹配任何非数字字符（相当于 [^0-9]）。

\s：匹配任何空白字符，包括空格、制表符、换行符等。

\S：匹配任何非空白字符。

\t：匹配制表符。

\n：匹配换行符。

\r：匹配回车符。

.：匹配除换行符外的任何字符。
</code></pre></div></div>

<ul>
  <li>斜杠后可以添加修饰符，可以叠加，常用如下</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g 匹配全部
使用示例：/abc/g
描述：返回所有匹配项，比如abc_abc_abc_abc

i 修饰符（不区分大小写）：
使用示例：/abc/i
描述：使正则表达式匹配时不区分大小写。

m 修饰符（多行匹配）：
使用示例：/abc/m
描述：使正则表达式匹配多行文本。

s 修饰符（单行匹配）：
使用示例：/abc/s
描述：使 . 元字符匹配包括换行符在内的任意字符。

u 修饰符（Unicode 匹配）：
使用示例：/abc/u
描述：启用 Unicode 匹配模式，用于处理 Unicode 字符。

y 修饰符（粘附匹配）：
使用示例：/abc/y
描述：执行粘附匹配，从目标字符串的当前位置开始匹配。
</code></pre></div></div>

<ul>
  <li>常用符号</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[]：方括号用于定义一个字符类，表示在该位置可以匹配方括号内列举的任意一个字符。
    例如，正则表达式 /[aeiou]/ 可以匹配任何一个元音字母
[^]：在字符类的开始位置使用 ^ 表示否定，表示匹配除列举字符之外的任意字符。
    例如，正则表达式 /[^0-9]/ 可以匹配任何非数字字符。
+：符号，它表示匹配前面的模式的一个或多个连续出现。
*：表示匹配零个或多个
.：匹配除换行符 \n 之外的任意单个字符。
    例如，正则表达式 /a.b/ 可以匹配 "aab"、"acb"、"a@b" 等字符串
?：匹配前面的模式零次或一次（可选匹配）
    例如，正则表达式 /colou?r/ 可以匹配 "color" 或 "colour" 字符串
()：创建捕获组，用于分组和提取匹配的子字符串。
    例如，正则表达式 /(ab)+/ 可以匹配 "ab"、"abab"、"ababab" 等字符串，并且捕获组可以提取出匹配的子字符串。
    捕获组可以在正则表达式中使用括号进行嵌套和组合，以构建更复杂的模式。在匹配成功后，可以通过索引或特殊变量来引用捕获组中提取的子字符串。例如，在 JavaScript 中，可以使用 $1、$2、$3 等变量来引用第一个、第二个、第三个捕获组提取的子字符串。
{}：大括号 {} 用于指定匹配的重复次数
    例如，\d{4} 匹配恰好四位数字
    {n,}：匹配前面的模式至少出现 n 次，例如，\d{2,} 匹配至少两位数字
    {n,m}：匹配前面的模式出现 n 到 m 次，例如，\d{2,4} 匹配两位到四位数字
</code></pre></div></div>

<ul>
  <li>一个例子</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 匹配电子邮件格式</span>
<span class="kd">const</span> <span class="nx">email</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">example@example.com</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">isValidEmail</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">[^\s</span><span class="sr">@</span><span class="se">]</span><span class="sr">+@</span><span class="se">[^\s</span><span class="sr">@</span><span class="se">]</span><span class="sr">+</span><span class="se">\.[^\s</span><span class="sr">@</span><span class="se">]</span><span class="sr">+$/</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">email</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">isValidEmail</span><span class="p">);</span> <span class="c1">// Output: true</span>

<span class="c1">// .test() 是 JavaScript 正则表达式对象的一个方法。它用于测试一个字符串是否与正则表达式匹配。</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^：匹配输入的开始位置。
[^\s@]+：匹配一个或多个非空白字符和非 @ 字符的字符。
@：匹配 @ 字符。
[^\s@]+：匹配一个或多个非空白字符和非 @ 字符的字符。
\.：匹配 . 字符。需要使用 \ 进行转义，因为 . 在正则表达式中是一个特殊字符，表示匹配任意字符。
[^\s@]+：匹配一个或多个非空白字符和非 @ 字符的字符。
$：匹配输入的结束位置。
</code></pre></div></div>

<ul>
  <li>另一个例子，把xx2020-01-01yy改成xx2020年01月01日</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">xx2020-01-01yy</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">(\d{4})</span><span class="sr">-</span><span class="se">(\d{2})</span><span class="sr">-</span><span class="se">(\d{2})</span><span class="sr">/</span><span class="p">,</span>
  <span class="p">(</span><span class="nx">match</span><span class="p">,</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">年</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">p2</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">月</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">p3</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">日</span><span class="dl">'</span><span class="p">;</span> <span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="c1">// xx2020年01月01日yy</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/(\d{4})-(\d{2})-(\d{2})/ 匹配形如 "yyyy-mm-dd" 格式的日期

匹配成功后，replace() 方法会调用一个回调函数，用于处理匹配到的结果。这个回调函数接受多个参数，其中第一个参数 match 是匹配到的完整字符串，后面的参数 p1、p2、p3 分别是匹配到的子字符串，即年、月、日。

</code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-23-regular_expression/image_1.jpg) -->]]></content><author><name></name></author><category term="js" /><category term="knowhow" /><summary type="html"><![CDATA[头尾两个斜杠 // 通常用于包裹正则表达式的模式，用来标识正则表达式的开始和结束]]></summary></entry><entry><title type="html">vue: 前端性能优化之关于视图的更新方式</title><link href="/vue/js/knowhow/view_update/" rel="alternate" type="text/html" title="vue: 前端性能优化之关于视图的更新方式" /><published>2023-10-23T12:59:59+08:00</published><updated>2023-10-23T12:59:59+08:00</updated><id>/vue/js/knowhow/view_update</id><content type="html" xml:base="/vue/js/knowhow/view_update/"><![CDATA[<h2 id="回流reflow">回流（reflow）</h2>

<ul>
  <li>对 DOM 结构的修改引发 DOM 几何尺寸变化的时候,会发生回流过程。</li>
</ul>

<p><strong>触发回流的操作：</strong></p>

<ol>
  <li>DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。</li>
  <li>使 DOM 节点发生增减或者移动。</li>
  <li>当需要计算元素的几何属性（如宽度、高度、位置等）时，浏览器会进行回流操作，重新计算元素的布局信息。读取或写入 offset、scroll 和 client 相关属性时，也会导致浏览器进行回流操作。（offset族、scroll族和client族）
    - offset：用于获取元素在页面中的位置和尺寸信息，包括 offsetTop、offsetLeft、offsetWidth 和 offsetHeight。
    - scroll：用于获取或设置元素的滚动信息，包括 scrollTop、scrollLeft、scrollWidth 和 scrollHeight。
    - client：用于获取或设置元素的可视区域信息，包括 clientTop、clientLeft、clientWidth 和 clientHeight。</li>
  <li>调用 window.getComputedStyle 方法。该方法返回元素的计算样式（computed style），而计算样式需要考虑元素的布局信息。因此，浏览器在执行 getComputedStyle 方法时，会强制进行回流操作</li>
</ol>

<h2 id="重绘">重绘</h2>

<ul>
  <li>
    <p>元素样式的改变并不影响它在文档流中的位置时触发重绘</p>
  </li>
  <li>
    <p>例如：color、background-color、visibility等</p>
  </li>
  <li>
    <p>重绘不一定导致回流，但回流一定发生了重绘</p>
  </li>
</ul>

<h2 id="合成">合成</h2>

<ul>
  <li>跳过布局和绘制，transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速</li>
  <li>直接进入合成线程</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-23-view_update/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><category term="knowhow" /><summary type="html"><![CDATA[回流（reflow）]]></summary></entry><entry><title type="html">vue: 前端性能优化之节流函数</title><link href="/vue/js/Throttling_function/" rel="alternate" type="text/html" title="vue: 前端性能优化之节流函数" /><published>2023-10-23T12:39:42+08:00</published><updated>2023-10-23T12:39:42+08:00</updated><id>/vue/js/Throttling_function</id><content type="html" xml:base="/vue/js/Throttling_function/"><![CDATA[<h2 id="节流">节流</h2>

<ul>
  <li>
    <p>节流函数是一种用于限制函数执行频率的技术，可以有效地控制事件触发频率，减少不必要的函数执行次数，提高前端性能和用户体验。</p>
  </li>
  <li>
    <p>一个例子</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">throttle</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timerId</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">timerId</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
      
      <span class="nx">timerId</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="nx">timerId</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>上述节流函数接受两个参数：func 是要执行的函数，delay 是限制的时间间隔（以毫秒为单位）。函数内部使用一个定时器来控制函数的执行时间。当事件触发时，如果定时器未启动，则会启动定时器，并在指定的延迟后执行函数。如果定时器已经启动，则不会执行任何操作，从而限制了函数的执行频率。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">throttledFunction</span> <span class="o">=</span> <span class="nf">throttle</span><span class="p">(</span><span class="nx">myFunction</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
<span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">throttledFunction</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>（一些库中提供节流函数，比如lodash、Underscore.js）</li>
</ul>

<h2 id="防抖">防抖</h2>

<ul>
  <li>防抖函数是一种用于控制函数执行频率的技术，类似于节流函数。不同之处在于，防抖函数会在连续触发事件后等待一段时间后执行函数，如果在等待时间内再次触发事件，则重新计时等待时间。防抖函数适用于那些连续触发的事件，但我们只关心最后一次触发的结果。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">debounce</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timerId</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
    
    <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timerId</span><span class="p">);</span>
    <span class="nx">timerId</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">debouncedFunction</span> <span class="o">=</span> <span class="nf">debounce</span><span class="p">(</span><span class="nx">myFunction</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>

<span class="nx">inputElement</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="nx">debouncedFunction</span><span class="p">);</span>

</code></pre></div></div>

<p><strong>防抖函数在以下情况下非常有用：</strong></p>

<ul>
  <li>
    <p>频繁触发的事件：对于一些频繁触发的事件，如窗口调整大小、滚动事件或用户输入等，防抖函数可以控制事件回调函数的执行频率，避免过多的触发和执行。这可以减轻浏览器的负担，并提高性能和响应速度。</p>
  </li>
  <li>
    <p>用户输入：在实时搜索、自动完成或自动保存等场景中，当用户在输入框中连续输入时，防抖函数可以延迟执行相关操作，直到用户停止输入一段时间后再进行处理。这样可以减少不必要的请求或操作，并提供更流畅的用户体验。</p>
  </li>
  <li>
    <p>避免重复提交：在表单提交或按钮点击等场景中，防抖函数可以防止用户多次触发重复操作。通过设置适当的等待时间，只有在最后一次触发事件后才会执行相关操作，避免了重复提交的问题。</p>
  </li>
  <li>
    <p>函数节流：尽管防抖函数和节流函数有些细微差别，但在某些情况下，防抖函数也可以用作函数节流的方式。例如，当需要限制函数的执行频率时，防抖函数可以确保函数在一定时间间隔内只执行一次，而忽略中间的触发。</p>
  </li>
</ul>

<p><strong>区分</strong></p>

<ul>
  <li>执行时机：
    <ul>
      <li>节流函数：在一定的时间间隔内，只执行一次函数，即限制函数的执行频率。无论事件触发频率是多高，节流函数都会按照固定的时间间隔执行函数。</li>
      <li>防抖函数：在连续触发事件后，等待一段时间后执行函数，如果在等待时间内再次触发事件，则重新计时等待时间。防抖函数会等待一段时间，确保事件不再触发后才执行函数。</li>
    </ul>
  </li>
  <li>执行结果：
    <ul>
      <li>节流函数：在指定的时间间隔内，只执行一次函数，并返回最后一次函数执行的结果。</li>
      <li>防抖函数：等待一段时间后，只执行一次函数，并返回最后一次函数执行的结果。</li>
    </ul>
  </li>
  <li>应用场景：
    <ul>
      <li>节流函数：适用于需要限制函数执行频率的场景，例如监听滚动事件、窗口调整大小事件等。常用于减少事件处理的次数，提高性能。</li>
      <li>防抖函数：适用于连续触发事件但只关心最后一次触发结果的场景，例如实时搜索、延迟加载、防止重复提交等。常用于控制事件回调的执行时机，提供更好的用户体验。</li>
    </ul>
  </li>
</ul>

<!--![引入图片](/image/vue/2023-10-23-Throttling_function/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><summary type="html"><![CDATA[节流]]></summary></entry><entry><title type="html">vue: 前端性能优化之will-change</title><link href="/vue/js/wil_change/" rel="alternate" type="text/html" title="vue: 前端性能优化之will-change" /><published>2023-10-23T12:27:01+08:00</published><updated>2023-10-23T12:27:01+08:00</updated><id>/vue/js/wil_change</id><content type="html" xml:base="/vue/js/wil_change/"><![CDATA[<ul>
  <li>
    <p>不要将 will-change 应用于过多的元素。浏览器已经尽力优化了所有东西。一些较强的优化可能与 will-change 相关联，它们可能会使用大量机器资源，当过度使用时会导致页面变慢或消耗大量资源。</p>
  </li>
  <li>
    <p>谨慎使用。浏览器进行的优化通常是在尽可能短的时间内删除优化并恢复到正常状态。但是，将 will-change 直接添加到样式表中意味着目标元素通常会在不久的将来发生变化，而浏览器会保留优化更长的时间。因此，最好的做法是在更改发生之前和之后使用脚本代码开启和关闭 will-change。</p>
  </li>
  <li>
    <p>不要为了过早优化而将 will-change 应用于元素。如果你的页面表现良好，则不要仅仅为了提高一点速度而将 will-change 属性添加到元素中。will-change 旨在作为最后的手段使用，以尝试解决现有的性能问题。不应该用来预测性能问题。过度使用 will-change 将导致内存使用过多，并导致更复杂的渲染发生，因为浏览器试图为可能的更改做准备。这将导致更差的性能。</p>
  </li>
  <li>
    <p>要给它足够的时间来发挥作用。该属性旨在为开发者提供一种方法，让用户代理提前了解可能会发生变化的属性。然后浏览器可以选择在实际属性更改之前应用所需的任何提前优化。因此，重要的是给浏览器一些时间来实际执行优化。找到一些方法，预测某些事情将会在稍微提前的时间内发生，并在那时设置 will-change。</p>
  </li>
  <li>
    <p>请注意。当与创建层叠上下文的属性值一起使用（例如 will-change: opacity）时，will-change 实际上可能会影响元素的视觉外观，因为层叠上下文是提前创建的。</p>
  </li>
  <li>
    <p>在需要通过按键进行页面翻转的应用程序中（例如相册或幻灯片演示文稿），或者在页面内容较大、较复杂的应用程序中，将 will-change 属性包含在样式表中可能是合适的。这将让浏览器提前准备好转换，并允许在按键按下时实现流畅的页面转换效果。但是，在样式表中直接使用 will-change 属性时需要谨慎。这可能会导致浏览器将优化保留在内存中的时间比实际需要的时间更长。</p>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* 关键字值 */</span>

<span class="c">/* 表示没有特别指定哪些属性会变化，浏览器需要自己去猜，然后使用浏览器经常使用的一些常规方法优化。 */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">auto</span><span class="o">;</span> 
<span class="c">/* 表示开发者希望在不久后改变滚动条的位置或者使之产生动画。 */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">scroll-position</span><span class="o">;</span>
<span class="c">/* 表示开发者希望在不久后改变元素内容中的某些东西，或者使它们产生动画。 */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">contents</span><span class="o">;</span>

<span class="nt">will-change</span><span class="o">:</span> <span class="nt">transform</span><span class="o">;</span> <span class="c">/* &lt;custom-ident&gt; 示例  */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">opacity</span><span class="o">;</span> <span class="c">/* &lt;custom-ident&gt; 示例  */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">left</span><span class="o">,</span> <span class="nt">top</span><span class="o">;</span> <span class="c">/* 两个 &lt;animatable-feature&gt; 例子 */</span>

<span class="c">/* 全局值 */</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">inherit</span><span class="o">;</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">initial</span><span class="o">;</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">revert</span><span class="o">;</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">revert-layer</span><span class="o">;</span>
<span class="nt">will-change</span><span class="o">:</span> <span class="nt">unset</span><span class="o">;</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-23-wil_change/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><summary type="html"><![CDATA[不要将 will-change 应用于过多的元素。浏览器已经尽力优化了所有东西。一些较强的优化可能与 will-change 相关联，它们可能会使用大量机器资源，当过度使用时会导致页面变慢或消耗大量资源。]]></summary></entry><entry><title type="html">vue: video手动刷新</title><link href="/vue/video_ref/" rel="alternate" type="text/html" title="vue: video手动刷新" /><published>2023-10-23T12:17:48+08:00</published><updated>2023-10-23T12:17:48+08:00</updated><id>/vue/video_ref</id><content type="html" xml:base="/vue/video_ref/"><![CDATA[<ul>
  <li>区别于img可以响应式变化，video 元素的 src 属性的变化不会自动触发页面的刷新或重新加载视频。</li>
  <li>需要用load函数主动刷新</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nt">&lt;video</span> <span class="na">ref=</span><span class="s">"videoPlayer"</span>

<span class="na">if</span> <span class="na">(url_type(props.path) =</span><span class="s">=</span> <span class="err">'</span><span class="na">video</span><span class="err">')</span> <span class="err">{</span>
    <span class="na">videoPlayer.value.load</span><span class="err">()</span>
<span class="err">}</span>
</code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-23-video_ref/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><summary type="html"><![CDATA[区别于img可以响应式变化，video 元素的 src 属性的变化不会自动触发页面的刷新或重新加载视频。 需要用load函数主动刷新]]></summary></entry><entry><title type="html">zip_backyard: 重绘优化</title><link href="/zip_backyard/vue/repaint_/" rel="alternate" type="text/html" title="zip_backyard: 重绘优化" /><published>2023-10-21T11:54:56+08:00</published><updated>2023-10-21T11:54:56+08:00</updated><id>/zip_backyard/vue/repaint_</id><content type="html" xml:base="/zip_backyard/vue/repaint_/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/zip_backyard/2023-10-21-repaint_/image_1.jpg) -->]]></content><author><name></name></author><category term="zip_backyard" /><category term="vue" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">windows: edge浏览器查看页面repaint</title><link href="/windows/vue/zip_backyard/repaint_gif/" rel="alternate" type="text/html" title="windows: edge浏览器查看页面repaint" /><published>2023-10-20T21:04:31+08:00</published><updated>2023-10-20T21:04:31+08:00</updated><id>/windows/vue/zip_backyard/repaint_gif</id><content type="html" xml:base="/windows/vue/zip_backyard/repaint_gif/"><![CDATA[<h2 id="gif录制">gif录制</h2>

<ul>
  <li>好用的工具：https://www.screentogif.com/</li>
</ul>

<h2 id="edge检查页面回流情况">edge检查页面回流情况</h2>

<ul>
  <li>f12添加rendering，页面里绿色部分是repaint，蓝色是shift（布局位移）</li>
</ul>

<p><img src="/image/windows/2023-10-20-repaint_gif/image_1.gif" alt="引入图片" /></p>

<ul>
  <li>可以看到左侧hover时所有元素都在重绘，帧数下降到30</li>
  <li>后面尝试优化（首先打算用gpu加速的css属性试试（transform））</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="windows" /><category term="vue" /><category term="zip_backyard" /><summary type="html"><![CDATA[gif录制]]></summary></entry><entry><title type="html">leetcode: 信也笔试</title><link href="/leetcode/js/xinye/" rel="alternate" type="text/html" title="leetcode: 信也笔试" /><published>2023-10-20T20:02:55+08:00</published><updated>2023-10-20T20:02:55+08:00</updated><id>/leetcode/js/xinye</id><content type="html" xml:base="/leetcode/js/xinye/"><![CDATA[<h2 id="知识总结">知识总结</h2>

<ul>
  <li>js保留两位小数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ans</span><span class="p">.</span><span class="nf">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>ascii码相互转换</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ascii</span> <span class="o">=</span> <span class="nx">chr</span><span class="p">.</span><span class="nf">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">chr</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">ascii</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="计算利息">计算利息</h2>

<ul>
  <li>触及到知识盲区了</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 等额本金：每月还款 = （本金/贷款月数）+（本金-已还金额）*月利率
- 输入：120000,0.048,5,"principal"
- 输出：14640.00
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 等额本息：每月还款 = 本金*月利率*（1+月利率）^ 贷款月数 / [(1+月利率) ^ 贷款月数 -1]
- 输入：120000,0.048,5,"amortized"
- 输出：15214.14
</code></pre></div></div>

<ul>
  <li>生搬硬套题目公式得到的结果完全不对，gpt给的程序也算不对</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 利息计算，保留2位小数
 * @param amount int整型 借款金额
 * @param annualRate float浮点型 年化利率
 * @param years int整型 借款期限
 * @param repaymentType string字符串 还款方式：等额本金（principal）、等额本息（amortized）
 * @return float浮点型
 */</span>
<span class="kd">function</span> <span class="nf">calculateInterest</span><span class="p">(</span><span class="nx">amount</span><span class="p">,</span> <span class="nx">annualRate</span><span class="p">,</span> <span class="nx">years</span><span class="p">,</span> <span class="nx">repaymentType</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">const</span> <span class="nx">totalMonth</span> <span class="o">=</span> <span class="nx">years</span> <span class="o">*</span> <span class="mi">12</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">month</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">month</span> <span class="o">&lt;=</span> <span class="nx">totalMonth</span><span class="p">;</span> <span class="nx">month</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">repaymentType</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">principal</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">amount</span> <span class="o">/</span> <span class="nx">totalMonth</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">amount</span> <span class="o">-</span> <span class="nx">ans</span><span class="p">)</span> <span class="o">*</span> <span class="nx">annualRate</span>
            <span class="nx">ans</span> <span class="o">=</span> <span class="nf">parseInt</span><span class="p">(</span><span class="nx">ans</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span> <span class="c1">// 两位小数</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">repaymentType</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">amortized</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ans</span> <span class="o">+=</span> <span class="nx">amount</span> <span class="o">*</span> <span class="nx">annualRate</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">annualRate</span><span class="p">)</span> <span class="o">**</span> <span class="nx">totalMonth</span> <span class="o">/</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">annualRate</span><span class="p">)</span> <span class="o">**</span> <span class="nx">totalMonth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nx">ans</span> <span class="o">=</span> <span class="nf">parseInt</span><span class="p">(</span><span class="nx">ans</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span> <span class="c1">// 两位小数</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="dl">"</span><span class="s2">error: unexpected repaymentType</span><span class="dl">"</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">month</span><span class="p">,</span> <span class="nx">ans</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// return ans.toFixed(2) // 答题系统里没有这个方法</span>
    <span class="k">return</span> <span class="nx">ans</span><span class="o">-</span><span class="nx">amount</span>

<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">calculateInterest</span><span class="p">:</span> <span class="nx">calculateInterest</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">calculateInterest</span><span class="p">(</span><span class="mi">120000</span><span class="p">,</span> <span class="mf">0.048</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">principal</span><span class="dl">"</span><span class="p">))</span>
<span class="c1">// console.log(calculateInterest(120000, 0.048, 5, "amortized"))</span>
</code></pre></div></div>

<h2 id="判断回文串">判断回文串</h2>

<ul>
  <li>忽略大小写、空格、标点</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入："A man, a plan, a canal,            Panama"
输出：true
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param input string字符串 
 * @return bool布尔型
 */</span>
<span class="kd">function</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>

    <span class="c1">// 转换为基本格式</span>
    <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nf">toLowerCase</span><span class="p">()</span>
    <span class="nx">raw_string</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="nx">rm_list</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">!</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">:</span><span class="dl">"</span><span class="p">,</span><span class="dl">'</span><span class="s1">"</span><span class="dl">'</span><span class="p">,</span><span class="dl">"</span><span class="s2">'</span><span class="dl">"</span><span class="p">];</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">letter</span> <span class="k">of</span> <span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">rm_list</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">letter</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">raw_string</span> <span class="o">+=</span> <span class="nx">letter</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 判断回文</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">raw_string</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">raw_string</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">raw_string</span><span class="p">[</span><span class="nx">raw_string</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">raw_string</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">,</span> <span class="nx">raw_string</span><span class="p">[</span><span class="nx">raw_string</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">isPalindrome</span><span class="p">:</span> <span class="nx">isPalindrome</span>
<span class="p">};</span>


<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">isPalindrome</span><span class="p">(</span><span class="dl">"</span><span class="s2">A man, a plan, a canal,            Panama</span><span class="dl">"</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>rm_list显然是不合理的，第一次只写了一个逗号，通过率是80%，加长rm_list之后勉强100%通过了</li>
</ul>

<h2 id="字符串ascii1">字符串ascii+1</h2>

<ul>
  <li>（凯撒密码）</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param input string字符串 
 * @return string字符串
 */</span>
<span class="kd">function</span> <span class="nf">shiftCharacters</span><span class="p">(</span> <span class="nx">input</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>
    <span class="kd">let</span> <span class="nx">ans</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">chr</span> <span class="k">of</span> <span class="nx">input</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">ascii</span> <span class="o">=</span> <span class="nx">chr</span><span class="p">.</span><span class="nf">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nx">ans</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">ascii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">shiftCharacters</span> <span class="p">:</span> <span class="nx">shiftCharacters</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">shiftCharacters</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">))</span> <span class="c1">//"ifmmp"</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-20-xinye/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><summary type="html"><![CDATA[知识总结]]></summary></entry></feed>