<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-06T16:34:13+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">leetcode: 记某次笔试的5道题</title><link href="/leetcode/python/duozhuayu/" rel="alternate" type="text/html" title="leetcode: 记某次笔试的5道题" /><published>2023-10-06T16:14:24+08:00</published><updated>2023-10-06T16:14:24+08:00</updated><id>/leetcode/python/duozhuayu</id><content type="html" xml:base="/leetcode/python/duozhuayu/"><![CDATA[<h2 id="1-good-word">1. Good Word</h2>
<p>字符串中出现最多的字符数量m<br />
字符串中出现最少的字符数量n<br />
m/n = 整数且&gt;1
满足条件为Good Word</p>

<ul>
  <li>暴力求解：创建了一个dic，记录所有字母出现的次数</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isGoodWord</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># write code here
</span>        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">letter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dic</span> <span class="k">else</span> <span class="n">dic</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="p">[</span><span class="n">dic</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">dic</span> <span class="p">]</span>
        <span class="n">maxn</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">minn</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxn</span> <span class="o">%</span> <span class="n">minn</span> <span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">maxn</span><span class="o">/</span><span class="n">minn</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">isGoodWord</span><span class="p">(</span><span class="sh">"</span><span class="s">duozhuayu</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="2-升序链表合并">2. 升序链表合并</h2>

<ul>
  <li>
    <p>合并结果仍为升序链表</p>
  </li>
  <li>
    <p>遍历就完了</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">next_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">next_node</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge_orders</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">ListNode</span> <span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">ListNode</span> <span class="p">)</span> <span class="o">-&gt;</span><span class="n">ListNode</span><span class="p">:</span>
        <span class="c1"># write code here
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">ans</span>
        <span class="k">while</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="o">&lt;=</span><span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">.</span><span class="nb">next</span>


<span class="n">ln1</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="bp">None</span><span class="p">)))</span>
<span class="n">ln2</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
<span class="n">ans</span> <span class="o">=</span> <span class="nc">Solution</span><span class="p">().</span><span class="nf">merge_orders</span><span class="p">(</span><span class="n">ln1</span><span class="p">,</span><span class="n">ln2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="3-解压缩字符串">3. 解压缩字符串</h2>
<p>aabb =&gt; a(2)b(2)<br />
aabbaabb =&gt; (a(2)b(2))2<br />
只出现一次的字母不压缩</p>

<ul>
  <li>
    <p>这里我下面写的程序通过率只有60%</p>
  </li>
  <li>暴力求解：创建了一个函数get_cp，返回每个前括号对应的后括号的位置（list形式）</li>
  <li>本来应该在更新字符串时同步更新上面那个list，但有点错位懒得改了，每次循环都调用一遍get_cp</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">decompress</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">compressed_str</span><span class="p">:</span><span class="nb">str</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>        <span class="k">def</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">str_in</span><span class="p">):</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">letter</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="sh">"</span><span class="s">(</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">letter</span> <span class="o">==</span> <span class="sh">"</span><span class="s">)</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">cp_index</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">cp_index</span>

        <span class="n">cp_index</span> <span class="o">=</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
        <span class="k">while</span> <span class="nf">sum</span><span class="p">(</span><span class="n">cp_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cp</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">cp_index</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">cp</span><span class="p">:</span>
                    <span class="n">multi</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">[</span><span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">compressed_str</span> <span class="o">=</span> <span class="n">compressed_str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span> <span class="n">compressed_str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">cp</span><span class="p">]</span> <span class="o">*</span><span class="n">multi</span> <span class="o">+</span><span class="n">compressed_str</span><span class="p">[</span><span class="n">cp</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="nf">len</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)]</span>
                    <span class="n">cp_index</span> <span class="o">=</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">compressed_str</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">decompress</span><span class="p">(</span><span class="sh">"</span><span class="s">((a)2(b)2(c)2)2</span><span class="sh">"</span><span class="p">))</span>
<span class="c1"># print(Solution().decompress("((a)2)2"))
</span>
</code></pre></div></div>

<h2 id="4-货架编号">4. 货架编号</h2>
<p>（类似N字排序，但没找到规律，所以还是用了暴力解法）</p>

<p>等边直角三角形，左上起始，逆时针螺旋排序</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 6 5
2 4
3
</code></pre></div></div>

<p>输入三角形维度，输出横向遍历排序结果</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt; 3
&lt;&lt; [1,6,5,2,4,3]
</code></pre></div></div>

<ul>
  <li>
    <p>在本子上写了几圈，没找到统一的规律，决定用暴力解法，新建n维空矩阵，三个函数fill_down、fill_rightup、fill_left分别向三个方向填入数据，循环到填满左上区域为止</p>
  </li>
  <li>
    <p>这里通过率只有85%</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberOfShelves</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">N</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>        <span class="n">mt</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">fill_down</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="k">def</span> <span class="nf">fill_rightup</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
                <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>    
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="k">def</span> <span class="nf">fill_left</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">num0</span> <span class="o">=</span> <span class="n">num</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_down</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pos2</span><span class="p">)</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_rightup</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">pos2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_left</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            

            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">num0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">pos1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos2</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ans</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">numberOfShelves</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>


</code></pre></div></div>

<h2 id="5-bgp树">5. BGP树</h2>
<ul>
  <li>2^N字符串由01构成</li>
  <li>字符串中全为0，节点value设为B</li>
  <li>全1为P</li>
  <li>都有为G</li>
  <li>判定完当前节点后将字符串等分两半继续判定，到字符串无法二分为止</li>
  <li>输出二叉树后序遍历结果</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"10001101"
"PBGBBBGPPPBPGGG"
</code></pre></div></div>

<ul>
  <li>这题显然是有规律可循的，题解里都没给TreeNode定义</li>
  <li>但还是写了个暴力解法</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span><span class="n">TreeNode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span><span class="n">TreeNode</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">bpg</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">s</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">def</span> <span class="nf">bpg_str</span><span class="p">(</span><span class="n">bpgs</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">判断BPG</span><span class="sh">'''</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">bpgs</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">B</span><span class="sh">"</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="sh">"</span><span class="s">0</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">bpgs</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">P</span><span class="sh">"</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">G</span><span class="sh">"</span>
            
        <span class="k">def</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">生成二叉树</span><span class="sh">'''</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span>
            
            <span class="n">tnp</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">bpg_str</span><span class="p">(</span><span class="n">tns</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tnp</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">[:</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)])</span>
                <span class="n">tnp</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):])</span>
            <span class="k">return</span> <span class="n">tnp</span>
        
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">遍历</span><span class="sh">'''</span>
            <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">''</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="sh">''</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="k">return</span> <span class="nf">traverse</span><span class="p">(</span><span class="nf">create_tn</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">bpg</span><span class="p">(</span><span class="sh">"</span><span class="s">10001101</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-06-duozhuayu/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[1. Good Word 字符串中出现最多的字符数量m 字符串中出现最少的字符数量n m/n = 整数且&gt;1 满足条件为Good Word]]></summary></entry><entry><title type="html">python: 开根号</title><link href="/python/sqrt/" rel="alternate" type="text/html" title="python: 开根号" /><published>2023-10-05T19:01:27+08:00</published><updated>2023-10-05T19:01:27+08:00</updated><id>/python/sqrt</id><content type="html" xml:base="/python/sqrt/"><![CDATA[<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 法1：math.sqrt
</span><span class="kn">import</span> <span class="n">math</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># 法2：pow
</span><span class="n">x</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># 法3：**
</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mf">0.5</span>

<span class="c1"># 补充：cmath.sqrt支持复数
</span><span class="kn">import</span> <span class="n">cmath</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cmath</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">#类型为complex
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/python/2023-10-05-sqrt/image_1.jpg) -->]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[```py 法1：math.sqrt import math x = math.sqrt(n)]]></summary></entry><entry><title type="html">leetcode: 完全平方数</title><link href="/leetcode/python/numSquares/" rel="alternate" type="text/html" title="leetcode: 完全平方数" /><published>2023-10-05T17:31:28+08:00</published><updated>2023-10-05T17:31:28+08:00</updated><id>/leetcode/python/numSquares</id><content type="html" xml:base="/leetcode/python/numSquares/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>链接：https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>

<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>

<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 13
输出：2
解释：13 = 4 + 9
</code></pre></div></div>

<h2 id="题解">题解</h2>

<ul>
  <li>难点在于dp矩阵如何构建，以及如何拆分子问题</li>
  <li>设dp[i]表示最少需要多少个数的平方来表示整数i</li>
  <li>遍历[1,i]（实际上只需遍历[1,sqrt(i)]），设当前遍历到j，认为i中拆分出的平方数中包含j，那么只需找到i-j^2包含多少平方数即可，即有dp[i] = 1 + dp[i-j^2]；对于遍历的每一个j都可以得出一个解，其中的最小值即为对i的解</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numSquares</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">minn</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">minn</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minn</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">])</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">minn</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    
<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">numSquares</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-05-numSquares/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 解决智力问题</title><link href="/leetcode/python/mostPoints/" rel="alternate" type="text/html" title="leetcode: 解决智力问题" /><published>2023-10-05T16:10:23+08:00</published><updated>2023-10-05T16:10:23+08:00</updated><id>/leetcode/python/mostPoints</id><content type="html" xml:base="/leetcode/python/mostPoints/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>链接：https://leetcode.cn/problems/solving-questions-with-brainpower/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>

<p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [points_i, brainpower_i] 。</p>

<p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  points_i 的分数，但是你将 无法 解决接下来的 brainpower_i 个问题（即只能跳过接下来的 brainpower_i 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p>

<p>比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：<br />
如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。<br />
如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br />
请你返回这场考试里你能获得的 最高 分数。</p>

<h2 id="题解">题解</h2>

<ul>
  <li>dp[i]表示解决前i道问题的最高分数，边界dp[0] = 0，dp[1] = points_0</li>
  <li>类似打家劫舍问题，只不过打劫间隔不是固定的1，而是由brainpower决定</li>
  <li>类比打家劫舍可得dp[i] = max( dp[i-1], dp[i-?]+points_i )，其中dp[i-?]表示满足条件【解决问题i】最近的前一项，（注意满足条件的dp[i-?]可能不只有一项），为找出dp[i-?]可以遍历原数组，找出每一项在删除brainpower后对应的后一项，以此构建索引字典，比如下面的例子</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="c1"># 第0，1，2，3项对应的后一项分别是第3,3,3,4项，因此可以构建字典如下
</span><span class="p">{</span>
    <span class="mi">0</span><span class="p">:[],</span>
    <span class="mi">1</span><span class="p">:[],</span>
    <span class="mi">2</span><span class="p">:[],</span>
    <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># index&gt;3没有意义
</span><span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>但显然这样会提高时间复杂度，官方题解采用了另一种思路</li>
  <li>构建状态转移方程的意义在于找出相邻两项dp之间的关系，并不一定是dp[i]和dp[i-1]，也可以是dp[i]和dp[i+1]；我们可以反向思考：</li>
  <li>如果不解决第1道题目，dp[i] = dp[i+1]</li>
  <li>如果解决，下一道题目是<code class="language-plaintext highlighter-rouge">i + brainpower_i + 1</code>，也就是说此时有</li>
</ul>

<center>dp[i] = points_i + dp[i + brainpower_i + 1]</center>

<ul>
  <li>状态转移方程如下</li>
</ul>

<center>dp[i] = max( dp[i+1], points_i + dp[i + brainpower_i + 1] )</center>

<ul>
  <li>此时边界为dp[n] = 0，表示没有做任何题目，所求结果为dp[0]</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">mostPoints</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">questions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">questions</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># 解决每道题及以后题目的最高分数
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">questions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">questions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>因为i + questions[i][1] + 1有可能超出边界，即后面没有可以解的题目，此时可以认为dp[i + brainpower_i + 1] = dp[n] = 0，所以例程中使用了min直接把0赋值给算式</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-05-mostPoints/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 不同的二叉搜索树</title><link href="/leetcode/python/numTrees/" rel="alternate" type="text/html" title="leetcode: 不同的二叉搜索树" /><published>2023-10-05T13:34:41+08:00</published><updated>2023-10-05T13:34:41+08:00</updated><id>/leetcode/python/numTrees</id><content type="html" xml:base="/leetcode/python/numTrees/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/unique-binary-search-trees/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 3
输出：5
</code></pre></div></div>

<p><img src="/image/leetcode/2023-10-05-numTrees/image_1.jpg" alt="引入图片" /></p>

<h2 id="题解">题解</h2>

<ul>
  <li>
    <p>首先复习二叉搜索树：左孩子比父节点小，右孩子比父节点大；（中序遍历可以让节点有序）</p>
  </li>
  <li>遍历每个数字 i，将该数字作为树根，将 [1:(i-1)] 序列作为左子树，将[(i+1):n]序列作为右子树</li>
  <li>↑对每个数字i都可以拆分出两个子问题，因此可以考虑使用动态规划</li>
  <li>定义dp[n]为长度为n的序列能构成的不同二叉搜索树的数量，边界为dp[0] = 0；dp[1] = 1</li>
  <li>定义F[i][n]为数字i为根时的。。。二叉树的数量，显然有dp[n] = ΣF[i][n]</li>
  <li>如果能找出F[i][n] = f( dp[n] )的另一个关系，和上式联立就可以得出dp的状态转移方程</li>
  <li>可以从子问题的拆分入手，以i为根节点时的左右子树的数量分别可以表示为dp[i-1]和dp[n-i]，两边子树各的组合数即为F[i][n]，即笛卡尔积；可以表示为：F[i][n] = dp[i-1] × dp[n-i]</li>
  <li>状态转移方程为：dp[n] = Σ( dp[i-1] × dp[n-i] )</li>
</ul>

<blockquote>

  <ul>
    <li>补充：笛卡尔积</li>
    <li>两个集合X和Y的笛卡尔积 (Cartesian product)，又称直积，表示 X x Y，第一个对象是 X 的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</li>
    <li>示例：A = {a,b}, B = {0,1,2}，则<br />
A×B = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}<br />
B×A = {(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}</li>
  </ul>

</blockquote>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numTrees</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type n: int
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">G</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">G</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-05-numTrees/image_1.jpg) -->

<h2 id="补充">补充</h2>

<p>上面dp的函数被称为【卡塔兰数Cn】<br />
C0 = 1
C(n+1) = Cn * 2(2n+1)/(n+2)</p>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 9键输入法组合</title><link href="/leetcode/python/9_button_input/" rel="alternate" type="text/html" title="leetcode: 9键输入法组合" /><published>2023-10-04T20:42:31+08:00</published><updated>2023-10-04T20:42:31+08:00</updated><id>/leetcode/python/9_button_input</id><content type="html" xml:base="/leetcode/python/9_button_input/"><![CDATA[<ul>
  <li>Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题</li>
  <li>简述一下题目大意：9键输入法，给定按键序列，返回所有组合</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>比如按下23
所有可能的组合有['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
</code></pre></div></div>

<ul>
  <li>题目本身不难，循环嵌套再拼接就行了</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dic9</span><span class="o">=</span><span class="p">{</span>
        <span class="sh">"</span><span class="s">2</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">g</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">h</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">i</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">5</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">j</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">k</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">l</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">6</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">m</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">7</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">q</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">8</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">u</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">v</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">9</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">z</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">dic9</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">dic9</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">sv</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">letter</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">sv</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>（但是他妈的，python打印字符串列表时默认使用单引号，牛客判定结果用双引号，我的程序通过率是0%）</li>
  <li>（↑转义成纯字符串也通不过，妈的真是触及到知识盲区了）</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-04-9_button_input/image_1.jpg) -->

<h2 id="2023105补充">2023.10.5补充</h2>

<ul>
  <li>补充：笛卡尔积</li>
  <li>两个集合X和Y的笛卡尔积 (Cartesian product)，又称直积，表示 X x Y，第一个对象是 X 的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = {a,b}, B = {0,1,2}，则

A×B = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}

B×A = {(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}
</code></pre></div></div>

<ul>
  <li>内置模块itertools</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">))</span>

<span class="c1"># 示例用法
</span><span class="n">set1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">set3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(1, 'a', True), (1, 'a', False), (1, 'b', True), (1, 'b', False), (1, 'c', True), (1, 'c', False), (2, 'a', True), (2, 'a', False), (2, 'b', True), (2, 'b', False), (2, 'c', True), (2, 'c', False)]
</code></pre></div></div>

<ul>
  <li>稍微修改上面的代码就可以得到题目要求的结果</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 示例用法
</span><span class="n">set1</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">set3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['ace', 'acf', 'ade', 'adf', 'bce', 'bcf', 'bde', 'bdf']
</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题 简述一下题目大意：9键输入法，给定按键序列，返回所有组合]]></summary></entry><entry><title type="html">leetcode: 不同路径</title><link href="/leetcode/python/uniquePaths/" rel="alternate" type="text/html" title="leetcode: 不同路径" /><published>2023-10-04T19:19:58+08:00</published><updated>2023-10-04T19:19:58+08:00</updated><id>/leetcode/python/uniquePaths</id><content type="html" xml:base="/leetcode/python/uniquePaths/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？</p>
  </li>
</ul>

<h2 id="题解">题解</h2>

<ul>
  <li>自解（动态规划）：易知dp[i][j] = dp[i-1][j] + dp[i][j-1]，边界是当i或j=1时dp[i][j]=1</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">j</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">uniquePaths</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

</code></pre></div></div>

<ul>
  <li>（因为最近在刷动态规划，双眼被蒙蔽了）</li>
  <li>想要走到右下角，总步数是固定的m+n-2，向右几步和向下几步也都是固定的，向下m-1次，向右n-1次；所以路径总是就是从m+n-2次移动中选择m-1次向下移动的方案数，即组合数：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C(m-1)(m+n-2) = (m+n-2)! / (m-1)!(n-1)!
</code></pre></div></div>

<ul>
  <li>一行公式就可以解决</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-04-uniquePaths/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 打家劫舍</title><link href="/leetcode/python/rob/" rel="alternate" type="text/html" title="leetcode: 打家劫舍" /><published>2023-10-04T16:33:58+08:00</published><updated>2023-10-04T16:33:58+08:00</updated><id>/leetcode/python/rob</id><content type="html" xml:base="/leetcode/python/rob/"><![CDATA[<h2 id="打家劫舍">打家劫舍</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre></div></div>

<ul>
  <li>首先看边界，只有一间房屋时，dp[0] = List[0]；两间房屋时dp[1] = max(List)</li>
  <li>接下来考虑递推关系。这道题很像之前的青蛙跳阶问题，在青蛙跳阶中，跳到第10级有2种方法：9+1或8+2；在这一题中，小偷偷10家也有2种方法：偷前9家或8+1，收益最大的方法即为解，所以状态转移方程：dp[n] = max( dp[n-1], dp[n-2]+List[n] )</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">len_s</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">len_s</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len_s</span><span class="p">]</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">rob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>

</code></pre></div></div>

<ul>
  <li>注意因为向前追溯了2位到dp[i-2]，所以dp的长度增加了1位，即(len_s+1)而不是len_s，i需要从2开始循环</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-04-rob/image_1.jpg) -->

<h2 id="打家劫舍plus---删除并获得点数">打家劫舍plus - 删除并获得点数</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/delete-and-earn/description/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：给你一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素（这些元素被删除后不获得点数）。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
</code></pre></div></div>

<ul>
  <li>下面解释一下为什么这道题是打家劫舍plus</li>
  <li>每次选择后都删除了所有nums[i] - 1 和 nums[i] + 1，可以理解为失去了点数sum([x for x in nums if x == nums[i] ± 1])</li>
  <li>考虑存在多个nums[i]的情况，因为第一次选择完之后已经删除了所有满足条件的元素，所有nums[i]可以重复选择直至全部选中，也就是说选择nums[i]相当于获得了点数sum([x for x in nums if x == nums[i]])</li>
  <li>影响最终结果的是所有相同元素的和，而不是单个的元素，因此可以以nums[i]为key，以sum([x for x in nums if x == nums[i]])为value构建新的数组，示例如下</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; [0,1,2,3,3]
&lt;&lt;&lt; [0,1,2,6]
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; [2, 2, 3, 3, 3, 4]
&lt;&lt;&lt; [0, 0, 4, 9, 4]
</code></pre></div></div>

<ul>
  <li>这时删除了所有nums[i] - 1 和 nums[i] + 1即意味着在新数组中无法选中相邻数字，也就是“相邻房屋会报警”</li>
  <li>（看到这里不得不甘拜下风）</li>
</ul>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[打家劫舍]]></summary></entry><entry><title type="html">leetcode: 斐波那契数列</title><link href="/leetcode/python/fib/" rel="alternate" type="text/html" title="leetcode: 斐波那契数列" /><published>2023-10-04T16:22:28+08:00</published><updated>2023-10-04T16:22:28+08:00</updated><id>/leetcode/python/fib</id><content type="html" xml:base="/leetcode/python/fib/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>链接：https://leetcode.cn/problems/fibonacci-number/description/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>

<h2 id="题解">题解</h2>

<ul>
  <li>题目就是给n求fib(n)</li>
  <li>可以用动态规划的方法来理解</li>
  <li>边界条件是dp(0) = 0, dp(1) = 1</li>
  <li>
    <p>状态转移方程是 dp(n) = dp(n-1)+dp(n-2)</p>
  </li>
  <li>为了节省空间，可以用p、q、r仅保留dp的后三位，滚动赋值</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-10-04-fib/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="nf">fib</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nb">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nf">for </span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> 
            <span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> 
            <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 正则表达式匹配</title><link href="/leetcode/python/isMatch/" rel="alternate" type="text/html" title="leetcode: 正则表达式匹配" /><published>2023-10-04T15:11:51+08:00</published><updated>2023-10-04T15:11:51+08:00</updated><id>/leetcode/python/isMatch</id><content type="html" xml:base="/leetcode/python/isMatch/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/regular-expression-matching/</p>
  </li>
  <li>
    <p>题目：</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给你一个字符串 s （string）和一个字符规律 p（pattern），请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
</code></pre></div></div>

<ul>
  <li>示例</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。


Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
</code></pre></div></div>

<h2 id="题解">题解</h2>

<ul>
  <li>
    <p>初见没有正确率理解题意中的匹配0次，从第二个示例可以看出包含’*‘前面的字母c在内都可以不被匹配，也就是说’*‘和前面的字母必须被看作一个整体</p>
  </li>
  <li>
    <p>字母和’.’的情况不多赘述，主要讨论’*‘的情况</p>
  </li>
  <li>
    <p>dp矩阵dp[i][j]表示s的前i个字符可以和p的前j个字符匹配，关键问题是如何构造状态转移方程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了1次
                        i     
                        ↓       
s[i]    a       a       a       b
p[j]    a       a       a       *       b
                                ↑
                                j
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了0次
                        i
                        ↓
s[i]    a       a       b
p[j]    a       a       a       *       b
                                ↑
                                j
</code></pre></div></div>

<ul>
  <li>将星号（p[j]）和前一个字母（p[j-1]）视为整体，进行匹配时有2种情况：
    <ul>
      <li>目标字母（s[i]）和模板字母（p[j-1]）不同，即【字母+星号】匹配了0次，此时能否匹配取决于【字母+星号】前一位，即p[j-2]，判断s[i] ?= p[j-2]，如果前一位匹配，即dp[i][j-2]=True，则dp[i][j]=True</li>
      <li>目标字母（s[i]）和模板字母（p[j-1]）相同，这里又分为两种情况：
        <ul>
          <li>1.虽然相同但s[i]匹配的实际上是星号后面的内容，即此处的【字母+星号】依然匹配了0次（下面图示的状态，这里i处的a实际上应该匹配j+1处的a），这种情况和上面的情况属于同一种情况，为了处理它，可以把这里的计算结果与上面计算的dp[i][j-2]进行与运算，这就是为什么题解中使用了|=而不是直接赋值
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 匹配了0次
              i
              ↓
s[i]    a       a       b
p[j]    a       a       *       a       b
                      ↑
                      j
</code></pre></div>            </div>
          </li>
          <li>2.相同且确实匹配，此时【字母+星号】匹配了1次或多次，为了找到所有可能的匹配，需要向前追溯目标字符串，即s[i-1]，判断s[i-1] ?= p[j]。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>上述所有情况中只要有一条成立，就可以判断匹配成功，所以程序中始终在用<code class="language-plaintext highlighter-rouge">|=</code>更新dp[i][j]的值</li>
</ul>

<!-- ![引入图片](/image/leetcode/2023-10-04-isMatch/image_1.jpg) -->

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span><span class="n">p</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nf">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>



<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">isMatch</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="sh">'</span><span class="s">aab</span><span class="sh">'</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="sh">'</span><span class="s">aaa*b</span><span class="sh">'</span><span class="p">))</span>

</code></pre></div></div>

<ul>
  <li>好的，虽然尽力理解了这么多，但其实还是没有完全理解，不愧是困难题，（这题跳过）</li>
</ul>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry></feed>