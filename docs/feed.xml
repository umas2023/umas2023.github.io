<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-14T22:08:26+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">jekyll: 添加背景图片</title><link href="/jekyll/background/" rel="alternate" type="text/html" title="jekyll: 添加背景图片" /><published>2023-10-14T22:06:39+08:00</published><updated>2023-10-14T22:06:39+08:00</updated><id>/jekyll/background</id><content type="html" xml:base="/jekyll/background/"><![CDATA[<ul>
  <li>一开始想加在home.html中发现没有效果，查看发现home.html上面还有一行layout: base，也就是说base.html才是真正的根节点</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"{{ page.lang | default: site.lang | default: "</span> <span class="na">en</span><span class="err">"</span> <span class="err">}}"</span><span class="nt">&gt;</span>

{%- include head.html -%}

<span class="nt">&lt;body&gt;</span>
  <span class="c">&lt;!-- 背景图 --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"bg-img"</span><span class="nt">&gt;&lt;/div&gt;</span>

  {%- include header.html -%}

  <span class="nt">&lt;main</span> <span class="na">class=</span><span class="s">"page-content"</span> <span class="na">aria-label=</span><span class="s">"Content"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"wrapper"</span><span class="nt">&gt;</span>
      {{ content }}
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/main&gt;</span>

  {%- include footer.html -%}

<span class="nt">&lt;/body&gt;</span>

<span class="nt">&lt;style </span><span class="na">scoped</span><span class="nt">&gt;</span>
  <span class="c">/* 背景图片 */</span>
  <span class="nt">div</span><span class="nc">.bg-img</span> <span class="p">{</span>
    <span class="nl">background-image</span><span class="p">:</span> <span class="sx">url("{{site.url}}/static/background.svg")</span><span class="p">;</span>
    <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
    <span class="nl">background-repeat</span><span class="p">:</span> <span class="nb">repeat</span><span class="p">;</span>
    <span class="nl">background-size</span><span class="p">:</span> <span class="m">400px</span><span class="p">;</span>
    <span class="nl">z-index</span><span class="p">:</span> <span class="m">-2</span><span class="p">;</span>
    <span class="nl">opacity</span><span class="p">:</span> <span class="m">0.1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>

<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/jekyll/2023-10-14-background/image_1.jpg) -->]]></content><author><name></name></author><category term="jekyll" /><summary type="html"><![CDATA[一开始想加在home.html中发现没有效果，查看发现home.html上面还有一行layout: base，也就是说base.html才是真正的根节点]]></summary></entry><entry><title type="html">leetcode: 58笔试</title><link href="/leetcode/js/function_call/" rel="alternate" type="text/html" title="leetcode: 58笔试" /><published>2023-10-14T21:00:04+08:00</published><updated>2023-10-14T21:00:04+08:00</updated><id>/leetcode/js/function_call</id><content type="html" xml:base="/leetcode/js/function_call/"><![CDATA[<ul>
  <li>依旧是算法题不难，选择题逆天</li>
  <li>因为是第一次用js写算法题，所以记录一下</li>
</ul>

<h2 id="查找出现次数最多的字符">查找出现次数最多的字符</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>


<span class="c1">// 查找字符串中出现次数最多的字符</span>
<span class="c1">// 可能有多个重复字符</span>

<span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 返回给定字符串中出现频率最高的字符
 * @param str string字符串 给定的字符串
 * @return string字符串一维数组
 */</span>
<span class="kd">function</span> <span class="nf">findChar</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>
    <span class="kd">let</span> <span class="nx">charCount</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">chr</span> <span class="k">of</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">charCount</span><span class="p">[</span><span class="nx">chr</span><span class="p">]){</span>
            <span class="nx">charCount</span><span class="p">[</span><span class="nx">chr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
            <span class="nx">charCount</span><span class="p">[</span><span class="nx">chr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="nx">maxList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">chr</span> <span class="k">in</span> <span class="nx">charCount</span><span class="p">){</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">charCount</span><span class="p">[</span><span class="nx">chr</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">charCount</span><span class="p">[</span><span class="nx">maxList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">){</span>
            <span class="nx">maxList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">chr</span><span class="p">]</span>
        <span class="p">}</span> 
        <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="nx">charCount</span><span class="p">[</span><span class="nx">chr</span><span class="p">]</span> <span class="o">==</span> <span class="nx">charCount</span><span class="p">[</span><span class="nx">maxList</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&amp;&amp;</span> <span class="nx">chr</span><span class="o">!=</span><span class="nx">maxList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">){</span>
            <span class="nx">maxList</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">chr</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">maxList</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">findChar</span><span class="p">:</span> <span class="nx">findChar</span>
<span class="p">};</span>


<span class="nf">findChar</span><span class="p">(</span><span class="dl">"</span><span class="s2">asdfghjklaqwertyuiopiaia135</span><span class="dl">"</span><span class="p">)</span>


</code></pre></div></div>

<h2 id="斐波那契数列">斐波那契数列</h2>

<ul>
  <li>使用递归法超时了，改用迭代</li>
  <li>也可以用动态规划的思想迭代</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="c1">// 斐波那契数列</span>


<span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 返回斐波那契数列第n项的数字
 * @param n long长整型 数列中的第n项
 * @return long长整型
 */</span>
<span class="kd">function</span> <span class="nf">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 递归法超时</span>
    <span class="c1">// if(n&lt;=1){</span>
    <span class="c1">//     return 1</span>
    <span class="c1">// }</span>
    <span class="c1">// return fib(n-1) + fib(n-2)</span>


    <span class="c1">// 试试迭代</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">pre</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">pre</span> <span class="o">+</span> <span class="nx">cur</span>
        <span class="nx">pre</span> <span class="o">=</span> <span class="nx">cur</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cur</span>


<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">fib</span><span class="p">:</span> <span class="nx">fib</span>
<span class="p">};</span>


<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-14-function_call/image_1.jpg) -->

<h2 id="中文转数字">中文转数字</h2>

<ul>
  <li>这题比较有意思</li>
  <li>关键在于对零的判断</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入 "二百零五万三千三百三十三"
输出 2053333
</code></pre></div></div>

<ul>
  <li>通过率只有85%，没有找到问题</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="c1">// 中文转数字</span>

<span class="c1">// "二百零五万三千三百三十三"</span>
<span class="c1">// 2053333</span>

<span class="c1">// 通过率85%</span>



<span class="cm">/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 请实现一个将中文数字转换为阿拉伯数字的方法
 * @param chineseNumber string字符串 中文数字字符串
 * @return int整型
 */</span>
<span class="kd">function</span> <span class="nf">chineseToNumber</span><span class="p">(</span><span class="nx">chineseNumber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>
    <span class="kd">const</span> <span class="nx">numberMap</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">零</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="na">一</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">二</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="na">三</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="na">四</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="na">五</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="na">六</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="na">七</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="na">八</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="na">九</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="na">十</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="na">百</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="na">千</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="na">万</span><span class="p">:</span> <span class="mi">10000</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">ansNumber</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">curNumber</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">lastNumber</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">cnNum</span> <span class="k">of</span> <span class="nx">chineseNumber</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">intNum</span> <span class="o">=</span> <span class="nx">numberMap</span><span class="p">[</span><span class="nx">cnNum</span><span class="p">]</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">intNum</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">curNumber</span> <span class="o">+=</span> <span class="nx">intNum</span>
            <span class="c1">// 一万零二这种情况</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">intNum</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">curNumber</span> <span class="o">=</span> <span class="nx">ansNumber</span>
                <span class="nx">ansNumber</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="c1">// 一万零二十这种情况要记住二，再在下面处理十</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">curNumber</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">lastNumber</span> <span class="o">=</span> <span class="nx">intNum</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">curNumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// "十七"这种情况</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">intNum</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">curNumber</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="p">}</span>
                <span class="c1">// 一千万这种情况</span>
                <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">intNum</span> <span class="o">==</span> <span class="mi">10000</span><span class="p">){</span>
                    <span class="nx">ansNumber</span> <span class="o">*=</span> <span class="mi">10000</span>
                <span class="p">}</span>

            <span class="p">}</span>
            <span class="c1">// 处理一万零二十的十</span>
            <span class="k">else</span> <span class="k">if </span><span class="p">((</span><span class="nx">lastNumber</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">intNum</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">ansNumber</span> <span class="o">=</span> <span class="nx">curNumber</span> <span class="o">-</span> <span class="nx">lastNumber</span>
                <span class="nx">curNumber</span> <span class="o">=</span> <span class="nx">lastNumber</span> <span class="o">*</span> <span class="nx">intNum</span>
                <span class="nx">ansNumber</span> <span class="o">+=</span> <span class="nx">curNumber</span>
                <span class="nx">curNumber</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nx">lastNumber</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">curNumber</span> <span class="o">*=</span> <span class="nx">intNum</span>
                <span class="nx">ansNumber</span> <span class="o">+=</span> <span class="nx">curNumber</span>
                <span class="nx">curNumber</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nx">lastNumber</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">cnNum</span><span class="p">,</span> <span class="nx">curNumber</span><span class="p">,</span> <span class="nx">ansNumber</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">curNumber</span> <span class="o">+</span> <span class="nx">ansNumber</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">chineseToNumber</span><span class="p">:</span> <span class="nx">chineseToNumber</span>
<span class="p">};</span>


<span class="c1">// console.log(chineseToNumber("二百零五万三千三百三十三"))</span>
<span class="c1">// console.log(chineseToNumber("一万零二"))</span>
<span class="c1">// console.log(chineseToNumber("一万零二十"))</span>
<span class="c1">// console.log(chineseToNumber("一千万"))</span>
<span class="c1">// console.log(chineseToNumber("一千万零一百"))</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">chineseToNumber</span><span class="p">(</span><span class="dl">"</span><span class="s2">一千零一万零一十一</span><span class="dl">"</span><span class="p">))</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><summary type="html"><![CDATA[依旧是算法题不难，选择题逆天 因为是第一次用js写算法题，所以记录一下]]></summary></entry><entry><title type="html">js: call函数</title><link href="/js/function_call/" rel="alternate" type="text/html" title="js: call函数" /><published>2023-10-14T17:08:42+08:00</published><updated>2023-10-14T17:08:42+08:00</updated><id>/js/function_call</id><content type="html" xml:base="/js/function_call/"><![CDATA[<h2 id="首先了解什么是call">首先了解什么是call</h2>

<ul>
  <li>在 JavaScript 中，函数是对象的方法。如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstName</span><span class="p">:</span><span class="dl">"</span><span class="s2">Bill</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">lastName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Gates</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">fullName</span><span class="p">:</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">person</span><span class="p">.</span><span class="nf">fullName</span><span class="p">();</span>		<span class="c1">// 将返回 "Bill Gates"</span>
</code></pre></div></div>

<ul>
  <li>
    <p>上面的例子中fullName 属性是一个方法。person 对象是该方法的拥有者。fullName 属性属于 person 对象的方法。</p>
  </li>
  <li>
    <p>call() 方法是预定义的 JavaScript 方法。它可以用来调用所有者对象作为参数的方法。通过 call()，您能够使用属于另一个对象的方法。下例调用 person 的 fullName 方法，并用于 person1：</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">fullName</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstName</span><span class="p">:</span><span class="dl">"</span><span class="s2">Bill</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">lastName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Gates</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">firstName</span><span class="p">:</span><span class="dl">"</span><span class="s2">Steve</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">lastName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Jobs</span><span class="dl">"</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">fullName</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">person1</span><span class="p">);</span>  <span class="c1">// 将返回 "Bill Gates"</span>
</code></pre></div></div>

<ul>
  <li>call方法可以接受参数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">fullName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">city</span><span class="p">,</span> <span class="nx">country</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">,</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">city</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">,</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">country</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">firstName</span><span class="p">:</span><span class="dl">"</span><span class="s2">Bill</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">lastName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Gates</span><span class="dl">"</span>
<span class="p">}</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">fullName</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">person1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Seattle</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">USA</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="然后自己实现一个call">然后自己实现一个call</h2>

<ul>
  <li>下面是gpt写的，但我觉得hr要的应该不是这个</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 自定义的 call 函数实现</span>
<span class="kd">function</span> <span class="nf">myCall</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 检查 fn 是否为函数</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">fn</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCall 只能用于函数</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 将函数作为上下文对象的一个属性</span>
  <span class="kd">const</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="nc">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">temp</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">context</span><span class="p">[</span><span class="nx">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>

  <span class="c1">// 使用 eval 执行函数并获取结果</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nf">eval</span><span class="p">(</span><span class="dl">'</span><span class="s1">context[symbol](...args)</span><span class="dl">'</span><span class="p">);</span>

  <span class="c1">// 删除添加的属性</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">[</span><span class="nx">symbol</span><span class="p">];</span>

  <span class="c1">// 返回函数执行的结果</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 示例用法</span>
<span class="kd">function</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span> <span class="p">};</span>

<span class="nf">myCall</span><span class="p">(</span><span class="nx">greet</span><span class="p">,</span> <span class="nx">person</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Symbol是JavaScript中的一种原始数据类型，引入于ES6（ECMAScript 2015）标准。它是一种唯一且不可变的数据类型，用于表示一个独一无二的标识符。</p>
  </li>
  <li>
    <p>与其他原始数据类型（如字符串、数字和布尔值）不同，Symbol值在内存中是唯一的。每个Symbol值都是独一无二的，即使它们具有相同的描述。</p>
  </li>
  <li>
    <p>在示例代码中，我们使用Symbol(‘temp’)创建了一个带有描述符为”temp”的Symbol值，并将其作为临时属性名添加到上下文对象中。通过这种方式，我们确保了该属性名的唯一性，不会与上下文对象中的其他属性名冲突。</p>
  </li>
  <li>
    <p>context[symbol] = fn 这行代码的意思是将一个函数 fn 赋值给对象 context 的一个属性，而该属性的名称是 symbol 所表示的 Symbol 值。</p>
  </li>
  <li>
    <p>在 JavaScript 中，eval 函数接受一个字符串参数，并将该字符串作为 JavaScript 代码进行解析和执行。在这个特定的表达式中，我们使用 eval 函数来执行一个动态生成的函数调用。</p>
  </li>
  <li>
    <p>在上面的示例中，greet 函数是要调用的函数，person 对象是作为上下文对象传递给 myCall 函数的参数，也就是说在myCall中context = person</p>
  </li>
  <li>
    <p>根据对代码的理解，简化了gpt的代码如下：</p>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">myCall</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">fn</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCall 只能用于函数</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 创建一个唯一的属性名</span>
  <span class="kd">const</span> <span class="nx">propertyName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">__myCall__</span><span class="dl">'</span><span class="p">;</span>

  <span class="c1">// 将函数赋值给上下文对象的属性</span>
  <span class="nx">context</span><span class="p">[</span><span class="nx">propertyName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>

  <span class="c1">// 使用属性名调用函数并获取结果</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">[</span><span class="nx">propertyName</span><span class="p">]();</span>

  <span class="c1">// 删除临时属性</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">[</span><span class="nx">propertyName</span><span class="p">];</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 示例用法</span>
<span class="kd">function</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span> <span class="p">};</span>

<span class="nf">myCall</span><span class="p">(</span><span class="nx">greet</span><span class="p">,</span> <span class="nx">person</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>简单来说就是，person内部没有greet方法，在myCall里把greet方法加入到person中，调用完后再删掉</li>
  <li>因为greet加入了person，所以可以共享this</li>
</ul>

<!--![引入图片](/image/js/2023-10-14-function_call/image_1.jpg) -->]]></content><author><name></name></author><category term="js" /><summary type="html"><![CDATA[首先了解什么是call]]></summary></entry><entry><title type="html">leetcode: js反转二叉树</title><link href="/leetcode/js/invertBinaryTree/" rel="alternate" type="text/html" title="leetcode: js反转二叉树" /><published>2023-10-14T17:01:33+08:00</published><updated>2023-10-14T17:01:33+08:00</updated><id>/leetcode/js/invertBinaryTree</id><content type="html" xml:base="/leetcode/js/invertBinaryTree/"><![CDATA[<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="kd">function</span> <span class="nf">invertBinaryTree</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="c1">// 交换左右子节点</span>
    <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">;</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  
    <span class="c1">// 递归反转左子树和右子树</span>
    <span class="nf">invertBinaryTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
    <span class="nf">invertBinaryTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
  
    <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 示例用例</span>
  <span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">原始二叉树:</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  
  <span class="kd">const</span> <span class="nx">invertedRoot</span> <span class="o">=</span> <span class="nf">invertBinaryTree</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">反转后的二叉树:</span><span class="dl">'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">invertedRoot</span><span class="p">);</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-14-category_tag/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><summary type="html"><![CDATA[class TreeNode { constructor(val) { this.val = val; this.left = null; this.right = null; } } function invertBinaryTree(root) { if (!root) { return null; } // 交换左右子节点 let temp = root.left; root.left = root.right; root.right = temp; // 递归反转左子树和右子树 invertBinaryTree(root.left); invertBinaryTree(root.right); return root; } // 示例用例 const root = new TreeNode(4); root.left = new TreeNode(2); root.right = new TreeNode(7); root.left.left = new TreeNode(1); root.left.right = new TreeNode(3); root.right.left = new TreeNode(6); root.right.right = new TreeNode(9); console.log('原始二叉树:'); console.log(root); const invertedRoot = invertBinaryTree(root); console.log('反转后的二叉树:'); console.log(invertedRoot);]]></summary></entry><entry><title type="html">jekyll: jekyll首页添加分类tag标签</title><link href="/jekyll/category_tag/" rel="alternate" type="text/html" title="jekyll: jekyll首页添加分类tag标签" /><published>2023-10-14T16:45:18+08:00</published><updated>2023-10-14T16:45:18+08:00</updated><id>/jekyll/category_tag</id><content type="html" xml:base="/jekyll/category_tag/"><![CDATA[<ul>
  <li>
    <p>首先找到主页的模板，比如我的是./_layouts/home.html</p>
  </li>
  <li>
    <p>查找里面的for循环就可以定位每条post的格式了</p>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    {%- for post in posts -%}
    <span class="nt">&lt;li&gt;</span>
      <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"post-meta"</span><span class="nt">&gt;</span>{{ post.date | date: date_format }}<span class="nt">&lt;/span&gt;</span>
      <span class="nt">&lt;h3&gt;</span>
        <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">"post-link"</span> <span class="na">href=</span><span class="s">"{{ post.url | relative_url }}"</span><span class="nt">&gt;</span>
          {{ post.title | escape }}
        <span class="nt">&lt;/a&gt;</span>
      <span class="nt">&lt;/h3&gt;</span>
      <span class="nt">&lt;h5&gt;</span>{{ post.info | escape }}<span class="nt">&lt;/h5&gt;</span>
      {%- if site.show_excerpts -%}
      {{ post.excerpt }}
      {%- endif -%}
    <span class="nt">&lt;/li&gt;</span>
    {%- endfor -%}
</code></pre></div></div>

<ul>
  <li>在上面的title和info之间添加分类tag</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    {%- for post in posts -%}
    <span class="nt">&lt;li&gt;</span>
      <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"post-meta"</span><span class="nt">&gt;</span>{{ post.date | date: date_format }}<span class="nt">&lt;/span&gt;</span>
      <span class="nt">&lt;h3&gt;</span>
        <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">"post-link"</span> <span class="na">href=</span><span class="s">"{{ post.url | relative_url }}"</span><span class="nt">&gt;</span>
          {{ post.title | escape }}
        <span class="nt">&lt;/a&gt;</span>
      <span class="nt">&lt;/h3&gt;</span>

      <span class="c">&lt;!-- 添加分类标签 --&gt;</span>
      {% for category in post.categories %}
      <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"category"</span><span class="nt">&gt;</span>{{ category }}<span class="nt">&lt;/span&gt;</span>
      {% endfor %}

      <span class="nt">&lt;h5&gt;</span>{{ post.info | escape }}<span class="nt">&lt;/h5&gt;</span>
      {%- if site.show_excerpts -%}
      {{ post.excerpt }}
      {%- endif -%}
    <span class="nt">&lt;/li&gt;</span>
    {%- endfor -%}
</code></pre></div></div>

<ul>
  <li>底部再定义一些格式</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;style </span><span class="na">scoped</span><span class="nt">&gt;</span>

  <span class="nt">span</span><span class="nc">.category</span><span class="p">{</span>
    <span class="nl">padding</span><span class="p">:</span> <span class="m">2px</span> <span class="m">5px</span> <span class="m">2px</span> <span class="m">5px</span><span class="p">;</span>
    <span class="nl">border-radius</span><span class="p">:</span> <span class="m">5px</span><span class="p">;</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="m">0.5em</span><span class="p">;</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">0.4</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<p><img src="/image/jekyll/2023-10-14-category_tag/image_1.jpg" alt="引入图片" /></p>

<ul>
  <li>文章内添加tag也一样，找到文章的模板后添加，我的是post.html</li>
  <li>注意这里是page.categories而不是post.categories</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: base
---
<span class="nt">&lt;article</span> <span class="na">class=</span><span class="s">"post"</span><span class="nt">&gt;</span>

  <span class="c">&lt;!-- 标题 --&gt;</span>
  <span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">"post-header"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1</span> <span class="na">class=</span><span class="s">"post-title"</span><span class="nt">&gt;</span>{{ page.title | escape }}<span class="nt">&lt;/h1&gt;</span>
    
    <span class="c">&lt;!-- 分类tag --&gt;</span>
    {% for category in page.categories %}
    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"category"</span><span class="nt">&gt;</span>{{ category }}<span class="nt">&lt;/span&gt;</span>
    {% endfor %}

    <span class="nt">&lt;h3&gt;</span>{{ page.info | escape }}<span class="nt">&lt;/h3&gt;</span>
  <span class="nt">&lt;/header&gt;</span>

  <span class="c">&lt;!-- 目录 --&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
  {% toc %}
  <span class="nt">&lt;hr&gt;</span>

  <span class="c">&lt;!-- 内容主体 --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"post-content"</span><span class="nt">&gt;</span>
    {{ content }}
  <span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;/article&gt;</span>


<span class="nt">&lt;style </span><span class="na">scoped</span><span class="nt">&gt;</span>

  <span class="nt">span</span><span class="nc">.category</span><span class="p">{</span>
    <span class="nl">padding</span><span class="p">:</span> <span class="m">2px</span> <span class="m">5px</span> <span class="m">2px</span> <span class="m">5px</span><span class="p">;</span>
    <span class="nl">border-radius</span><span class="p">:</span> <span class="m">5px</span><span class="p">;</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="m">0.5em</span><span class="p">;</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="n">rgba</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">0.4</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="jekyll" /><summary type="html"><![CDATA[首先找到主页的模板，比如我的是./_layouts/home.html]]></summary></entry><entry><title type="html">vue: vue双向绑定</title><link href="/vue/knowhow/mvvm/" rel="alternate" type="text/html" title="vue: vue双向绑定" /><published>2023-10-14T16:25:39+08:00</published><updated>2023-10-14T16:25:39+08:00</updated><id>/vue/knowhow/mvvm</id><content type="html" xml:base="/vue/knowhow/mvvm/"><![CDATA[<h2 id="vue双向绑定原理">vue双向绑定原理</h2>

<ul>
  <li>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MVC模式：Model，View，Control，单项绑定，js更新model，view就会更新
MVVM模式：Model–View–ViewModel，它实现了View的变动，自动反映在 ViewModel，反之亦然。
对于双向绑定的理解，就是用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定
</code></pre></div></div>

<ul>
  <li>监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者</li>
  <li>订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图</li>
  <li>解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）</li>
</ul>

<p>v-model是vue的一个语法糖，用于表单控件或者在组件上创建双向绑定。</p>

<h2 id="步骤">步骤</h2>

<p>第一步： 需要observer(观察者)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>

<p>第二步： compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>

<p>第三步： Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>

<p>第四步： MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-14-mvvm/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="knowhow" /><summary type="html"><![CDATA[vue双向绑定原理]]></summary></entry><entry><title type="html">vue: webpack loader</title><link href="/vue/knowhow/webpack_loader/" rel="alternate" type="text/html" title="vue: webpack loader" /><published>2023-10-14T16:01:56+08:00</published><updated>2023-10-14T16:01:56+08:00</updated><id>/vue/knowhow/webpack_loader</id><content type="html" xml:base="/vue/knowhow/webpack_loader/"><![CDATA[<ul>
  <li>参考：https://juejin.cn/post/6992754161221632030</li>
  <li>参考：https://zhuanlan.zhihu.com/p/104205895</li>
</ul>

<h2 id="webpack">webpack</h2>

<ul>
  <li>
    <p>Webpack 是一个模块化打包工具，它被广泛地应用在前端领域的大多数项目中。利用 Webpack 我们不仅可以打包 JS 文件，还可以打包图片、CSS、字体等其他类型的资源文件。而支持打包非 JS 文件的特性是基于 Loader 机制来实现的。</p>
  </li>
  <li>
    <p>webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。</p>
  </li>
</ul>

<h2 id="vite和webpack">vite和webpack</h2>

<ul>
  <li>vite</li>
</ul>

<p>基于原生 ES-Module 的前端构建工具
Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。</p>

<p>vite是基于es modules的，因为vite不允许commonjs的规范，所以vite就不会将所有的依赖读取一遍，也就提升了运行效率；而webpack则更多的关注兼容性，webpack在启动的时候需要读取所有的依赖，统一模块化代码，再启动服务器；而vite则是直接启动服务器按需加载，未用到的模块不会加载。webpack更关注兼容性，vite关注浏览器端的开发体验。</p>

<ul>
  <li>vite和vue-cli</li>
</ul>

<p>vue-cli 基于 webpack 封装，生产环境和开发环境都是基于 Webpack 打包。</p>

<h2 id="loader">loader</h2>

<ul>
  <li>
    <p>Loader 本质上是导出函数的 JavaScript 模块</p>
  </li>
  <li>常见的loader：
    <ul>
      <li>image-loader：加载并且压缩图片文件</li>
      <li>css-loader：帮助webpack打包处理css文件，使用css-loader必须要配合使用style-loader</li>
      <li>style-loader：用于将css编译完成的样式，挂载到页面的style标签上。但是要注意loader执行顺序，style-loader要放在第一位，loader都是从后往前执行</li>
      <li>babel-loader：把 ES6 转换成 ES5</li>
      <li>sass-loader: css预处理器，能更好的编写css</li>
      <li>postcss-loader: 用于补充css样式在各种浏览器的前缀，很方便，不需要手动写了</li>
      <li>eslint-loader:用于检查代码是否符合规范，是否存在语法错误</li>
      <li>url-loader:处理图片类型资源，可以根据图片的大小进行不同的操作，如果图片大小大于指定大小，则将图片进行资源打包，否则将图片转换为base64格式字符串，再把这个字符串打包到 JS文件里。</li>
    </ul>
  </li>
  <li>loader接收三个输入参数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {string|Buffer} content 源文件的内容
 * @param {object} [map] 可以被 https://github.com/mozilla/source-map 使用的 SourceMap 数据
 * @param {any} [meta] meta 数据，可以是任何内容
 */</span>
<span class="kd">function</span> <span class="nf">webpackLoader</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 你的webpack loader代码</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">webpackLoader</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>自定义一个简单的loader</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">simpleLoader</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">我是 SimpleLoader</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">content</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">simpleLoader</span><span class="p">;</span>
</code></pre></div></div>

<p>-以上的 simpleLoader 并不会对输入的内容进行任何处理，只是在该 Loader 执行时输出相应的信息。Webpack 允许用户为某些资源文件配置多个不同的 Loader，比如在处理 .css 文件的时候，我们用到了 style-loader 和 css-loader，具体配置方式如下所示：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// webpack.config.js</span>

<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">entry</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src/index.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">output</span><span class="p">:</span> <span class="p">{</span>
     <span class="na">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bundle.js</span><span class="dl">'</span><span class="p">,</span>
     <span class="na">path</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">'</span><span class="s1">dist</span><span class="dl">'</span><span class="p">),</span>
  <span class="p">},</span>
  <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">css$/i</span><span class="p">,</span>
        <span class="na">use</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">style-loader</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">css-loader</span><span class="dl">'</span><span class="p">],</span>
      <span class="p">},</span>
    <span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>Webpack 这样设计的好处，是可以保证每个 Loader 的职责单一。同时，也方便后期 Loader 的组合和扩展。比如，你想让 Webpack 能够处理 Scss 文件，你只需先安装 sass-loader，然后在配置 Scss 文件的处理规则时，设置 rule 对象的 use 属性为 [‘style-loader’, ‘css-loader’, ‘sass-loader’] 即可。</li>
</ul>

<h2 id="写一个loader">写一个loader</h2>

<ul>
  <li>参考：https://www.cnblogs.com/yincheng/p/webpack-loader.html</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-14-webpack_loader/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="knowhow" /><summary type="html"><![CDATA[参考：https://juejin.cn/post/6992754161221632030 参考：https://zhuanlan.zhihu.com/p/104205895]]></summary></entry><entry><title type="html">leetcode: 58同城2020前端笔试</title><link href="/leetcode/js/wuba2020/" rel="alternate" type="text/html" title="leetcode: 58同城2020前端笔试" /><published>2023-10-11T21:35:36+08:00</published><updated>2023-10-11T21:35:36+08:00</updated><id>/leetcode/js/wuba2020</id><content type="html" xml:base="/leetcode/js/wuba2020/"><![CDATA[<ul>
  <li>链接：https://www.nowcoder.com/exam/test/74831907/detail?pid=30359331&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26keyword%3D58%26selectStatus%3D0&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91</li>
</ul>

<h2 id="1-以下代码图形">1. 以下代码图形</h2>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">:before</span> <span class="p">{</span>
    <span class="nl">content</span><span class="p">:</span> <span class="s2">''</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">border-left</span><span class="p">:</span> <span class="m">10px</span> <span class="nb">solid</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">border-top</span><span class="p">:</span> <span class="m">10px</span> <span class="nb">solid</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">border-bottom</span><span class="p">:</span> <span class="m">10px</span> <span class="nb">solid</span> <span class="nb">transparent</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>答案是上直角梯形</li>
  <li>经过测试发现在四个边框都设置了的情况下，四边是以四个梯形拼接的，但如果某一条边没有边框，梯形的尖角将被抹去，下面的图可以很好的理解</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>

<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"solution"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;script&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">html test</span><span class="dl">'</span><span class="p">)</span>
<span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;style&gt;</span>
    <span class="nt">div</span><span class="nf">#solution</span><span class="p">{</span>
        <span class="nl">padding-top</span><span class="p">:</span><span class="m">30px</span><span class="p">;</span>
        <span class="nl">height</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
        <span class="nl">width</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
        <span class="nl">border</span><span class="p">:</span> <span class="nb">solid</span> <span class="m">1px</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">div</span><span class="nf">#solution</span><span class="nd">::before</span> <span class="p">{</span>
        <span class="nl">content</span><span class="p">:</span> <span class="s2">'test'</span><span class="p">;</span>
        <span class="nl">width</span><span class="p">:</span> <span class="m">10000px</span><span class="p">;</span>
        <span class="nl">height</span><span class="p">:</span> <span class="m">100000px</span><span class="p">;</span>
        <span class="nl">border-top</span><span class="p">:</span> <span class="m">30px</span> <span class="nb">solid</span> <span class="no">green</span><span class="p">;</span>
        <span class="nl">border-left</span><span class="p">:</span> <span class="m">30px</span> <span class="nb">solid</span> <span class="no">red</span><span class="p">;</span>
        <span class="nl">border-bottom</span><span class="p">:</span> <span class="m">30px</span> <span class="nb">solid</span> <span class="no">blue</span><span class="p">;</span>
        <span class="nl">border-right</span><span class="p">:</span> <span class="m">30px</span> <span class="nb">solid</span> <span class="no">black</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>

<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="/image/leetcode/2023-10-11-wuba2020/image_1.jpg" alt="引入图片" /></p>

<ul>
  <li>
    <p>题目中因为底边框设置为透明，所以显示出了左边框的尖角</p>
  </li>
  <li>
    <p>补充：伪元素的宽高不能直接设置，而是根据内部包含的内容决定的，所以在content为空的情况下before元素宽度永远为0，也就是说题目中设置的top边框实际上是梯形退化成了三角形。根据默认字体大小，before元素会有一个高度，这就是为什么删掉上边框后梯形只是矮了一点，但删除左边框后梯形会完全消失</p>
  </li>
</ul>

<h2 id="2-请给出563324代码的运行结果">2. 请给出[5&lt;6&lt;3,3&lt;2&lt;4]代码的运行结果</h2>

<ul>
  <li>
    <p>答案是[true, true]</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>我们逐个解析这些表达式：</p>

<p>5 &lt; 6 &lt; 3:</p>

<p>首先，5 &lt; 6 会返回布尔值 true，因为 5 小于 6。
然后，true &lt; 3 会将布尔值 true 隐式转换为数字 1，因为在 JavaScript 中，true 被当作数字 1，false 被当作数字 0。
最后，判断 1 &lt; 3，这是一个比较运算，结果为 true。</p>

<p>3 &lt; 2 &lt; 4:</p>

<p>首先，3 &lt; 2 会返回布尔值 false，因为 3 不小于 2。
然后，false &lt; 4 会将布尔值 false 隐式转换为数字 0。
最后，判断 0 &lt; 4，这是一个比较运算，结果为 true。</p>

<h2 id="3-下面代码输出为true的是">3. 下面代码输出为true的是?</h2>

<p>A console.log([] === []);
B console.log(undefined == 0);
C console.log(undefined == false);
D console.log(false == ‘’);</p>

<ul>
  <li>
    <p>答案：D</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>A. console.log([] === []); 输出为 false。这是因为数组是引用类型，在比较时会比较引用地址，而这两个空数组是不同的引用，因此结果为 false。
B. console.log(undefined == 0); 输出为 false。这是因为 undefined 和数字 0 是不同的类型，它们之间没有隐式的类型转换，因此不相等。
C. console.log(undefined == false); 输出为 false。这是因为 undefined 和 false 是不同的类型，它们之间没有隐式的类型转换，因此不相等。
D. console.log(false == ‘’); 输出为 true。这是因为在比较相等性时，布尔值和字符串会被转换为数字。在转换过程中，false 被转换为数字 0，空字符串被转换为数字 0，因此它们相等。</p>

<h2 id="4-以下哪个不是伪类的属性">4. 以下哪个不是伪类的属性?</h2>

<p>A :before
B :active
C :hover
D :focus</p>

<ul>
  <li>答案：A: :before 是 CSS 伪元素，而不是伪类。它用于在元素内容之前插入生成的内容。</li>
</ul>

<p>伪元素用于创建一个在文档中不存在的虚拟元素，并对其进行样式化。</p>

<p>伪类用于选择元素的特定状态或状态的子集。</p>

<h2 id="5-以下哪个方法返回匹配的子字符串">5. 以下哪个方法返回匹配的子字符串？</h2>

<p>A contact()
B match()
C indexOf()
D search()</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: contact() 方法用于将两个字符串连接起来，而不是返回匹配的子字符串。
B: match() 方法用于在字符串中查找匹配某个正则表达式的子字符串，并将匹配的结果作为数组返回。可以使用正则表达式或字符串作为参数。
C: indexOf() 方法返回指定字符串在原字符串中第一次出现的索引位置，而不是返回匹配的子字符串。
D: search() 方法用于在字符串中查找与正则表达式匹配的子字符串，并返回第一个匹配的索引位置，而不是返回匹配的子字符串。</p>

<h2 id="6-以下关于javascript描述正确的是">6. 以下关于javascript描述正确的是？</h2>

<p>A javascript是一门面向对象的语言
B 变量使用之前必须声明
C javascript是一种编译性脚本语言
D javascript是由LiveScript语言发展而来</p>

<ul>
  <li>解析：</li>
</ul>

<p>A. JavaScript 是一门多范式的语言，支持面向对象编程、函数式编程和基于原型的编程等多种编程范式。
B. 在 JavaScript 中，变量在使用之前必须先进行声明。可以使用 var、let 或 const 关键字来声明变量。
C. JavaScript 是一种解释性脚本语言，而非编译性脚本语言。JavaScript 代码在运行时逐行解释执行，而不是事先编译为二进制代码。
D. JavaScript 最初是由 LiveScript 语言发展而来，但在发布时更名为 JavaScript。它与 Java 语言没有直接的关系，只是在命名上有些相似。</p>

<h2 id="7-以下哪个nodetype值对应的是文本节点">7. 以下哪个nodeType值对应的是文本节点？</h2>

<p>A 1
B 2
C 3
D 8</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: 1 对应的是元素节点（Element Node）的 nodeType 值。
B: 2 对应的是属性节点（Attribute Node）的 nodeType 值。
C: 3 对应的是文本节点（Text Node）的 nodeType 值。
D: 8 对应的是注释节点（Comment Node）的 nodeType 值。</p>

<ul>
  <li>补充：</li>
</ul>

<p>nodeType 是 DOM（文档对象模型）中的一个属性，用于表示节点的类型。</p>

<p>在 DOM 中，每个节点都有一个 nodeType 属性，它是一个整数值，用于标识节点的类型。这个值是一个预定义的常量，可以通过访问节点的 nodeType 属性来获取。</p>

<p>1: 元素节点（Element Node），表示 HTML 元素。
2: 属性节点（Attribute Node），表示 HTML 元素的属性。
3: 文本节点（Text Node），表示 HTML 元素中的文本内容。
4: CDATA 节点（CDATA Section Node），表示不会被解析为实体的文本块。
5: 实体引用节点（Entity Reference Node），表示实体引用。
6: 实体节点（Entity Node），表示实体。
7: 处理指令节点（Processing Instruction Node），表示处理指令。
8: 注释节点（Comment Node），表示注释。
9: 文档节点（Document Node），表示整个文档。
10: 文档类型节点（Document Type Node），表示文档类型。
11: 文档片段节点（Document Fragment Node），表示文档片段。
12: 表示 Notation 节点（Notation Node），表示符号。</p>

<h2 id="8-下列哪个不是块级元素">8. 下列哪个不是块级元素</h2>

<p>A div
B img
C h1
D ol</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: div 是块级元素，它是一个通用的块级容器。
B: img 是内联元素（行内元素），它用于在网页中插入图像。
C: h1 是块级元素，它表示标题级别 1 的标题。
D: ol 是块级元素，它表示有序列表。</p>

<h2 id="9-在javascript中下面哪个不属于数组的方法">9. 在javascript中，下面哪个不属于数组的方法</h2>

<p>A sort
B length
C reverse
D concat</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: sort 是数组的方法，用于对数组元素进行排序。
B: length 是数组的属性，而不是方法。它用于获取数组的长度（即数组中元素的数量）。
C: reverse 是数组的方法，用于反转数组中元素的顺序。
D: concat 是数组的方法，用于将多个数组或值连接成一个新数组。</p>

<h2 id="10-编写高性能javascript以下描述错误的是">10. 编写高性能JavaScript，以下描述错误的是</h2>

<p>A 遵循严格模式：”use strict”
B 将js脚本放在页面顶部，加快渲染页面
C 将js脚本成组打包，减少请求，尽量减少使用闭包
D 使用非阻塞方式下载js脚本，最小化重绘(repaint)和回流(reflow)</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: 遵循严格模式（”use strict”）可以提高代码的性能和安全性，它启用了一些限制和优化，帮助编写更高效的 JavaScript 代码。
B: 将 JavaScript 脚本放在页面底部，而不是顶部，可以加快页面的初始渲染速度。将脚本放在底部可以确保 HTML 内容优先加载和显示，避免阻塞页面渲染。
C: 将 JavaScript 脚本进行打包可以减少请求次数，从而提高性能。同时，尽量减少使用闭包可以避免额外的内存消耗和性能问题。
D: 使用非阻塞方式下载 JavaScript 脚本可以避免阻塞页面的渲染和加载。这可以通过将脚本放在 script 标签中的 async 或 defer 属性来实现，或者使用动态创建脚本元素的方式。</p>

<ul>
  <li>补充：</li>
</ul>

<p>关于严格模式：</p>

<p>使用严格模式可以通过在脚本或函数的开头添加特定的语句来启用，例如在脚本的开头添加 “use strict”; 或在函数的开头使用 “use strict”;。</p>

<p>严格模式的特点包括：</p>

<p>变量必须先声明：在严格模式下，使用未声明的变量会抛出错误。
禁止使用全局变量：在严格模式下，无法将变量或函数隐式声明为全局变量，避免了意外地污染全局命名空间。
禁止删除变量或函数：在严格模式下，无法使用 delete 运算符删除变量、函数或函数的参数。
禁止使用重复的参数名：在严格模式下，函数的参数名不能重复。
禁止使用八进制字面量：在严格模式下，八进制字面量（如 0123）会被视为无效，避免了一些令人困惑的行为。
禁止使用 eval：在严格模式下，eval 函数的作用域被限制在当前作用域内，无法访问外部作用域的变量。
限制 this 值：在严格模式下，全局作用域中的 this 值为 undefined，而不是指向全局对象。</p>

<p>关于闭包：</p>

<p>闭包（Closure）是指在一个函数内部创建的函数以及该函数能够访问的外部函数作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被内部函数访问和操作。</p>

<h2 id="11-如何最小化重绘repaint和回流reflow以下哪个是错的">11. 如何最小化重绘(repaint)和回流(reflow)，以下哪个是错的？</h2>

<p>A 需要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示
B 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document
C 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）
D 尽量不要使用 css 属性简写，如：用border-width, border-style, border-color代替border</p>

<ul>
  <li>解析：</li>
</ul>

<p>A: 当需要对元素进行复杂的操作时，例如修改多个样式属性或添加多个子元素，可以先将元素设置为隐藏（display: none），进行操作完成后再显示。这样可以避免在操作过程中多次触发重绘和回流，只在最后一次显示时触发一次重绘和回流。
B: 使用 DocumentFragment 可以减少回流次数。DocumentFragment 是一个轻量级的文档片段，可以在其中添加多个 DOM 节点，然后将整个文档片段一次性地加入到文档中，减少了多次回流。
C: 表格布局（table 元素）会触发一次回流，会导致表格内的其他元素也进行回流。因此，尽量避免过度使用表格布局，以减少回流的次数。
D: 使用 CSS 属性简写可以提高开发效率，但是会增加解析和计算的复杂性，可能导致额外的回流。因此，尽量使用单独的 CSS 属性来代替简写属性，例如使用 border-width、border-style 和 border-color 来代替 border 简写。</p>

<!--![引入图片](/image/leetcode/2023-10-11-wuba2020/image_1.jpg) -->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><summary type="html"><![CDATA[链接：https://www.nowcoder.com/exam/test/74831907/detail?pid=30359331&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26keyword%3D58%26selectStatus%3D0&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91]]></summary></entry><entry><title type="html">windows: vscode配置c++开发环境</title><link href="/windows/cpp/vscode_cpp/" rel="alternate" type="text/html" title="windows: vscode配置c++开发环境" /><published>2023-10-11T20:39:41+08:00</published><updated>2023-10-11T20:39:41+08:00</updated><id>/windows/cpp/vscode_cpp</id><content type="html" xml:base="/windows/cpp/vscode_cpp/"><![CDATA[<ul>
  <li>网上清一色安装MinGW，看起来超麻烦</li>
  <li>试一试vscode推荐的方法，新建窗口时欢迎页右侧有C++开发入门，介绍了环境的设置方法
    <ol>
      <li>安装MSVC，在下载页面搜索【Visual Studio 2022 生成工具】，页面：https://visualstudio.microsoft.com/zh-hans/downloads/</li>
      <li>安装程序中选择C++ 生成工具，我没找到，把c++全选了</li>
      <li>安装完成后终端键入cl，检查MSVC安装</li>
    </ol>
  </li>
</ul>

<p>（直接运行cpp时右下角会报错：仅当从 VS 开发人员命令提示符处运行 VS Code 时，cl.exe 生成和调试才可用。）</p>

<ol>
  <li>
    <p>开始菜单搜索developer，会找到Developer Powershell for VS 2022，打开它，在这个终端里输入code，会启动一个新的vscode界面，在这里写hello_world，点击F5或者右上角运行，选择C++什么调试器忘了，没及时记录</p>
  </li>
  <li>
    <p>但有一说一实际上这里编译运行的速度依然很美，还会生成许多中间文件，不如直接使用visual studio；或者在wsl里手动<code class="language-plaintext highlighter-rouge">gcc test.cpp -o test</code>，测试时发现报错找不到标准库，可以手动链接<code class="language-plaintext highlighter-rouge">g++ test.cpp -o test -lstdc++</code></p>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"hello"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<!--![引入图片](/image/windows/2023-10-11-vscode_cpp/image_1.jpg) -->]]></content><author><name></name></author><category term="windows" /><category term="cpp" /><summary type="html"><![CDATA[网上清一色安装MinGW，看起来超麻烦 试一试vscode推荐的方法，新建窗口时欢迎页右侧有C++开发入门，介绍了环境的设置方法 安装MSVC，在下载页面搜索【Visual Studio 2022 生成工具】，页面：https://visualstudio.microsoft.com/zh-hans/downloads/ 安装程序中选择C++ 生成工具，我没找到，把c++全选了 安装完成后终端键入cl，检查MSVC安装]]></summary></entry><entry><title type="html">leetcode: 58同城2021笔试</title><link href="/leetcode/js/python/wuba2021/" rel="alternate" type="text/html" title="leetcode: 58同城2021笔试" /><published>2023-10-11T14:01:57+08:00</published><updated>2023-10-11T14:01:57+08:00</updated><id>/leetcode/js/python/wuba2021</id><content type="html" xml:base="/leetcode/js/python/wuba2021/"><![CDATA[<ul>
  <li>链接：https://www.nowcoder.com/exam/test/74802082/detail?pid=36048429&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26keyword%3D58%E5%90%8C%E5%9F%8E%26selectStatus%3D0&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91</li>
</ul>

<h2 id="选择题">选择题</h2>

<ol>
  <li>以下代码输出</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">].</span><span class="nf">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">].</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span>
</code></pre></div></div>

<ul>
  <li>答案</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span> <span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>解析</li>
</ul>

<p>使用 splice() 方法会改变原始数组，返回被删除的元素组成的数组。<br />
起始索引为 1，要删除的元素数量为 2（即删除了索引位置 1 和 2 的元素），并在该位置插入元素 [3, 4, 5]。splice() 方法返回被删除的元素组成的数组，所以输出结果是 [2, 3]，表示被删除的元素为 2 和 3。</p>

<p>slice() 方法用于从数组中提取指定范围的元素，返回一个新数组，不会修改原始数组。它接受两个参数：
第一个参数 1 表示起始索引，指定了要提取的起始位置。
第二个参数表示要提取的结束位置。结束位置为 2,3,4,5（但 slice() 方法只接受两个参数，多余的参数会被忽略）</p>

<hr />
<hr />

<ol>
  <li>root元素的高 (通过getComputedStyle(root).height计算) 为？</li>
</ol>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"root"</span> <span class="na">style=</span><span class="s">"border:1px solid red;"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">"width:10px;height:10px;margin:10px;"</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">style=</span><span class="s">"width:10px;height:10px;margin:20px;"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<ul>
  <li>直接在console打印结果是70px</li>
  <li>(10 + 10x2) + (10 + 20x2) - 10px</li>
  <li>根据CSS规范中的外边距合并（Margin Collapsing）规则，当两个垂直相邻的元素具有外边距时，它们的外边距会发生合并，产生一个新的外边距。合并后的外边距的大小取决于两个元素中较大的外边距值。</li>
  <li>上面div的下边距10被合并到下面div的上边距20中了，所以要减去10</li>
  <li>由结果来看border边框是不计入高度的</li>
</ul>

<hr />
<hr />

<ol>
  <li>假定某次上线，1小时内出bug的概率为50%，那么3小时内出bug的概率是？</li>
</ol>

<ul>
  <li>答案：87.5</li>
  <li>解析：</li>
</ul>

<p>P3 = 在3小时内出现bug
noP3 = 在3小时内没有出现bug</p>

<p>P1b = 第1小时内 …
P1n = 第1 …</p>

<p>则 P3b = 1 - noP3 = 1 - ( P1n x P2n x P3n ) = 1 - 0.5x0.5x0.5 = 0.875</p>

<hr />
<hr />

<ol>
  <li>以下代码执行返回？</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">0x111</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>答案：273</li>
  <li>
    <p>解析：当字符串以 ‘0x’ 开头时，它被解释为十六进制数</p>
  </li>
  <li>补充：其他转换16进制的方法</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nb">Number</span><span class="p">.</span><span class="nf">parseInt</span><span class="p">(</span><span class="dl">'</span><span class="s1">0x111</span><span class="dl">'</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="dl">'</span><span class="s1">0x111</span><span class="dl">'</span><span class="p">).</span><span class="nf">valueOf</span><span class="p">());</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="o">+</span><span class="p">(</span><span class="dl">'</span><span class="s1">0x111</span><span class="dl">'</span><span class="p">))</span>
</code></pre></div></div>

<hr />
<hr />

<ol>
  <li>下边关于https描述正确的是:</li>
</ol>

<p>A 客户端会对服务器下发的证书进行域名校验
B 客户端和服务器交互使用的是服务器下发的私钥
C 黑客拦截服务器下发的证书后就可以伪造服务器和客户端进行通信
D 手机只信任CA颁发的证书</p>

<ul>
  <li>答案A</li>
  <li>解析：</li>
</ul>

<p>A：HTTPS 使用了公钥加密和证书来确保通信的机密性和身份验证。在建立 HTTPS 连接时，服务器会发送一个包含公钥的数字证书给客户端。客户端会对这个证书进行域名校验，以确保证书上的域名与客户端请求的域名匹配。这是为了防止中间人攻击，确保客户端与正确的服务器进行通信。</p>

<p>B：服务器使用私钥进行解密，客户端使用服务器的公钥进行加密。在 HTTPS 连接建立过程中，服务器会发送一个数字证书给客户端。这个证书包含了服务器的公钥以及其他相关信息，如证书的颁发机构、有效期等。</p>

<p>客户端在收到证书后，会使用证书中的公钥来加密生成一个对称密钥（也称为会话密钥或对话密钥）。这个对称密钥用于后续的通信加密和解密。</p>

<p>客户端随后将加密后的对称密钥发送给服务器。服务器在接收到加密的对称密钥后，使用自己的私钥进行解密，获取到对称密钥。</p>

<p>接下来的通信过程中，客户端和服务器会使用这个对称密钥来进行加密和解密，以保证通信的机密性和完整性。</p>

<p>C：如果黑客能够拦截服务器的证书，但无法伪造有效的证书，他们仍然无法成功伪造服务器和客户端之间的通信。证书的有效性取决于其由受信任的证书颁发机构（CA）签署。如果黑客试图伪造服务器和客户端之间的通信，他们需要拦截服务器的私钥，以便使用私钥解密客户端发送的对称密钥。但是，私钥是服务器保密的，并且应该妥善保护。只有服务器才能使用私钥进行解密操作。</p>

<p>D：手机或其他设备可以配置信任的根证书颁发机构列表，这些根证书颁发机构的证书将被信任。因此，不仅限于 CA 颁发的证书可以被手机信任。</p>

<hr />
<hr />

<ol>
  <li>下边关于XSS描述正确的是</li>
</ol>

<p>A XSS又名跨站脚本攻击，是利用服务器查询漏洞，在提交数据中注入sql语句，从而破坏网站数据</p>

<p>B 防范XSS攻击只要前端对数据进行Base64就可以解决</p>

<p>C XSS攻击需要也服务器对接口进行防护</p>

<p>D XSS攻击仅在表单提交时使用</p>

<ul>
  <li>答案：C</li>
  <li>解析：</li>
</ul>

<p>A. XSS（跨站脚本攻击）是一种利用网站漏洞，向用户的浏览器注入恶意脚本的攻击方式。A这是对 SQL 注入攻击的描述，不是 XSS 攻击。SQL 注入是通过在用户输入中注入恶意 SQL 语句来攻击数据库。</p>

<p>B. Base64 编码可以用于在数据传输过程中对数据进行编码，但它并不能完全解决 XSS 攻击。XSS 攻击是在网站中插入恶意脚本，而 Base64 编码只是一种编码方式，无法阻止恶意脚本的注入。</p>

<p>D. XSS 攻击并不仅限于表单提交。XSS 可以发生在任何用户输入的地方，包括 URL 参数、Cookie、HTTP 头和其他用户可控制的数据输入点。</p>

<ul>
  <li>补充：关于XSS</li>
</ul>

<p>XSS（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在受信任的网页中插入恶意脚本，使其在用户的浏览器上执行。这种攻击利用了网页应用程序对用户输入的不充分过滤和验证。</p>

<p>XSS 攻击的原理是攻击者将恶意的脚本代码注入到网页的输出内容中，当用户浏览该页面时，浏览器会执行这些恶意脚本，导致攻击者可以获取用户的敏感信息、篡改网页内容、劫持用户会话等恶意行为。</p>

<p>XSS 攻击可以分为三种类型：</p>

<p>存储型 XSS：攻击者将恶意脚本注入到目标网站的数据库中，当用户浏览受影响的页面时，恶意脚本从数据库中被提取并执行。</p>

<p>反射型 XSS：攻击者将恶意脚本作为参数附加在 URL 中，当用户点击包含恶意脚本的链接时，网站会将恶意脚本作为响应返回并在用户浏览器上执行。</p>

<p>DOM 型 XSS：攻击者利用 JavaScript 动态修改网页的 DOM 结构，将恶意脚本注入到页面中，当用户浏览该页面时，恶意脚本被执行。</p>

<p>防范 XSS 攻击的关键在于对用户输入进行有效的过滤和转义。以下是一些常见的防御措施：</p>

<p>1.输入验证和过滤：对用户输入进行严格的验证和过滤，确保只接受预期的数据格式，并剔除潜在的恶意脚本。</p>

<p>2.输出转义：在将用户输入插入到网页内容中之前，对特殊字符进行转义，确保它们被当作文本而不是脚本代码处理。</p>

<p>3.使用安全的编码方式：对于特定的上下文，使用适当的编码方式，如 HTML 实体编码、URL 编码等，以防止脚本被解析执行。</p>

<p>4.设置安全响应头：通过设置合适的安全响应头，如 Content-Security-Policy (CSP)，可以限制脚本的执行和资源加载，提供额外的安全保护。</p>

<p>5.定期更新和修复漏洞：及时更新和修复网站的软件和组件，以减少存在已知漏洞的风险。</p>

<hr />
<hr />

<ol>
  <li>以下运行结果:</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>答案：10个10</li>
  <li>这题我会，不用解析了</li>
</ul>

<hr />
<hr />

<ol>
  <li>在跨域请求中，下列请求头中哪种content-type一定会触发cors预检查</li>
</ol>

<p>A text/plain</p>

<p>B multipart/form-data</p>

<p>C application/x-www-form-unlencoded</p>

<p>D application/json</p>

<ul>
  <li>答案：D</li>
  <li>解析：如果 Content-Type 不属于以下几种类型之一，就会触发 CORS 预检查：</li>
</ul>

<p>1.application/x-www-form-urlencoded
2.multipart/form-data
3.text/plain</p>

<hr />
<hr />

<ol>
  <li>下面代码输出结果正确的是</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">Setcount</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="nx">Setcount</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">printCount</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Setcount</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">200</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">300</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nf">printCount</span><span class="p">()</span>
<span class="nx">a</span><span class="p">.</span><span class="nf">printCount</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>答案：300,200</li>
  <li>解析：</li>
</ul>

<p>调用 a._proto__.printCount() 会输出 300，因为在 printCount 方法中，this.count 引用的是原型对象上的 count 属性，而原型对象的 count 属性已经被修改为 300</p>

<p>调用 a.printCount() 会输出 200，因为在 printCount 方法中，this.count 引用的是实例对象 a 上的 count 属性，而实例对象的 count 属性值为 200。</p>

<hr />
<hr />

<ol>
  <li>关于position定位，下列说法正确的是</li>
</ol>

<p>A  relative，absolute, fixed都会脱离当前文档流，并相对于当前位置设置偏移量</p>

<p>B absolute元素如果其父级设置了fixed属性，则其会相对于浏览器窗口设置偏移</p>

<p>C z-index属性对元素position属性为relative，absolute, fixed都可以做层级设置</p>

<p>D relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间</p>

<ul>
  <li>
    <p>答案：C</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>A. 这个说法是不正确的。虽然relative、absolute和fixed定位可以脱离当前文档流，并相对于当前位置设置偏移量，但它们之间的具体行为和影响是不同的。</p>

<p>relative（相对定位）：</p>

<p>相对于元素在文档流中的原始位置进行定位。
通过设置top、right、bottom和left属性来指定相对于原始位置的偏移量。
元素在文档流中保留其原有的空间，其他元素不会填充该元素的位置。
相对定位不会影响其他元素的布局。</p>

<p>absolute（绝对定位）：</p>

<p>相对于最近的具有定位属性（relative、absolute或fixed）的祖先元素进行定位。
通过设置top、right、bottom和left属性来指定相对于定位祖先的偏移量。
元素从文档流中脱离，不保留原有的空间，其他元素会填充该元素的位置。
绝对定位会影响其他元素的布局，其他元素会根据绝对定位元素的位置进行调整。</p>

<p>fixed（固定定位）：</p>

<p>相对于浏览器窗口进行定位。
通过设置top、right、bottom和left属性来指定相对于窗口的偏移量。
元素从文档流中脱离，不保留原有的空间，其他元素会填充该元素的位置。
固定定位会影响其他元素的布局，其他元素会根据固定定位元素的位置进行调整。
固定定位的元素会随着页面滚动而保持在固定的位置，不受滚动影响。</p>

<p>B. 这个说法是不正确的。absolute定位元素的偏移是相对于最近的具有定位属性（relative、absolute或fixed）的祖先元素，而不是相对于浏览器窗口设置偏移。父级fixed不一定是浏览器窗口</p>

<p>C. 这个说法是正确的。z-index属性用于控制元素的层级关系，可以应用于position属性为relative、absolute和fixed的元素，以确定元素在堆叠顺序中的显示顺序。</p>

<p>D. 这个说法是不正确的。relative定位元素以它原来的位置为基准进行偏移，但是在其移动后，原来的位置仍然会占据空间。也就是说，相对定位的元素在文档流中仍然保留其原来的空间，不会被其他元素填充。</p>

<hr />
<hr />

<ol>
  <li>请选择console打印的正确值</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Object</span><span class="dl">'</span><span class="p">;</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Function</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">Animal</span> <span class="p">()</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">cat</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>答案：Object Function</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>在 JavaScript 中，创建对象的方式有多种，包括使用构造函数、字面量、Object.create() 等。不同的创建方式会影响对象的原型链。</p>

<p>对于 Animal 函数来说，它是一个构造函数，同时也是一个函数对象。函数对象在 JavaScript 中有一个特殊的原型 Function.prototype。所以 Animal 的原型链是 Animal -&gt; Function.prototype -&gt; Object.prototype -&gt; null。</p>

<p>由于 Animal 函数本身没有 foo 属性，JavaScript 会在原型链上查找。首先查找 Animal.prototype，再查找 Function.prototype</p>

<p>对于 cat 对象来说，它的原型链是 cat -&gt; Animal.prototype -&gt; Object.prototype -&gt; null。这是因为在创建 cat 对象时，使用了 new Animal()，这会将 Animal.prototype 设置为 cat 对象的原型。而 Animal.prototype 的原型是 Object.prototype。Animal.prototype 的原型是 Object.prototype，这是因为在 JavaScript 中，构造函数的原型对象默认继承自 Object.prototype</p>

<p>由于 cat 对象本身没有 foo 属性，JavaScript 会在原型链上查找。首先查找 Animal.prototype，再查找 Object.prototype</p>

<hr />
<hr />

<ol>
  <li>请选择正确的输出结果</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> 
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>答案 123和333</p>
  </li>
  <li>
    <p>这题我会</p>
  </li>
</ul>

<hr />
<hr />

<ol>
  <li>下列哪个属性不会引起浏览器重排（reflow）:</li>
</ol>

<p>A</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">@keyframes</span> <span class="n">animate</span> <span class="p">{</span>
        <span class="err">0</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">top</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
            <span class="nl">left</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="err">25</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">top</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
            <span class="nl">left</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="err">50</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">top</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
            <span class="nl">left</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="err">75</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">top</span><span class="p">:</span> <span class="m">200px</span><span class="p">;</span>
            <span class="nl">left</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>B</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">@keyframes</span> <span class="n">animate</span> <span class="p">{</span>
        <span class="err">0</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">transform</span><span class="p">:</span> <span class="n">translate</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="err">25</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">transform</span><span class="p">:</span> <span class="n">translate</span><span class="p">(</span><span class="m">200px</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="err">50</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">transform</span><span class="p">:</span> <span class="n">translate</span><span class="p">(</span><span class="m">200px</span><span class="p">,</span> <span class="m">200px</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="err">75</span><span class="o">%</span> <span class="p">{</span>
            <span class="nl">transform</span><span class="p">:</span> <span class="n">translate</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">200px</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>C</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.hide</span> <span class="p">{</span>
        <span class="nl">display</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>D</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">.hide</span> <span class="p">{</span>
        <span class="nl">visibility</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>答案：B</li>
  <li>解析：使用 transform 属性的动画不会引起浏览器重排（reflow）</li>
</ul>

<p>transform 属性是通过 GPU 加速进行处理的，不会引起浏览器重排。</p>

<p>GPU（图形处理单元）加速是一种利用计算机的图形处理硬件来加速图形渲染和动画的技术。在Web开发中，通过使用一些特定的CSS属性，如transform、opacity、filter等，可以触发GPU加速。</p>

<p>当使用GPU加速时，浏览器会将特定的渲染操作委托给GPU来处理，而不是由CPU来计算和渲染。由于GPU在处理图形计算方面具有强大的性能和并行处理能力，因此能够更快地完成渲染操作，提高动画的流畅性和性能。</p>

<hr />
<hr />

<p>14.关于javascript，以下选项描述错误的是哪几个</p>

<p>A 在原型上扩展的可枚举方法，会被for in循环出来
B 通过hasOwnProperty可判断一个对象以及其原型链上是否具有指定名称的属性
C 每个函数对象都有prototype属性，返回对象类型原型的引用
D For循环是按顺序的，for in 循环是不一定按顺序的
E for…of 循环可遍历普通对象，如{a:’1’, b:2}</p>

<ul>
  <li>答案：E</li>
  <li>解析：for…of 循环不能直接遍历普通对象（plain object）</li>
</ul>

<p>A. 在原型上扩展的可枚举方法会被 for…in 循环遍历出来。for…in 循环会遍历对象自身和继承的可枚举属性（包括原型链上的属性）。</p>

<p>B. 通过 hasOwnProperty 方法可以判断一个对象是否具有指定名称的属性，并且该属性必须是对象自身拥有的，不包括继承的属性。</p>

<p>C. 每个函数对象都有 prototype 属性，它是一个指向该函数类型的原型对象的引用。该原型对象包含了函数类型所创建的对象实例共享的属性和方法。</p>

<p>D. for 循环是按顺序迭代的，而 for…in 循环是不保证按顺序迭代的，它可能会以任意顺序遍历对象的属性。比如for…in 循环在遍历对象属性时，不保证按照特定顺序进行迭代，这是因为 JavaScript 中对象的属性没有固定的顺序。</p>

<p>E. 正确的是，for…of 循环不能直接遍历普通对象（plain object）。for…of 循环适用于可迭代对象（iterable objects），如数组、字符串、Set、Map 等，可以按顺序遍历它们的元素值。但普通对象并不是可迭代对象，所以无法使用 for…of 循环遍历普通对象的属性。</p>

<hr />
<hr />

<p>15.下列关于js事件的描述中，正确的有哪些</p>

<p>A 事件冒泡是指当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。
B 不支持冒泡的事件有blur、focus、load、resize、mouseleave
C 事件委托不依赖于事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
D 通过addEventListener方法给Dom添加事件监听，addEventListener形参中的第三个参数控制是捕获传递触发还是冒泡传递触发。</p>

<ul>
  <li>
    <p>答案：ACD</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>A. 事件冒泡是指当一个元素上的事件被触发时，同样的事件将在该元素的所有祖先元素中被触发。事件会从最内层的元素开始触发，然后逐级向上冒泡至最外层的元素。</p>

<p>选项 B 描述错误，因为 blur、focus、load、resize、mouseleave 等事件是支持冒泡的，它们可以在父元素中触发相应的事件处理程序。</p>

<p>C. 事件委托不依赖于事件冒泡，它指的是将事件处理程序绑定到父元素（或更上层元素），通过事件冒泡的机制来管理某一类型的所有子元素的事件。这样可以减少事件处理程序的数量，提高性能和代码简洁性。</p>

<p>D. 通过 addEventListener 方法给 DOM 添加事件监听，其中形参中的第三个参数控制是捕获传递触发还是冒泡传递触发。该参数是一个布尔值，为 true 表示使用捕获传递，为 false（默认值）表示使用冒泡传递。</p>

<ul>
  <li>补充：捕获传递（Capture Phase）和冒泡传递（Bubbling Phase）是指在事件处理过程中，事件在 DOM 树中传递的两个阶段。</li>
</ul>

<p>捕获传递（Capture Phase）：
在捕获阶段，事件从文档根节点开始向下传递，直到达到目标元素的父级元素。在这个阶段，父级元素的事件处理程序有机会先于目标元素的事件处理程序被调用。捕获传递阶段的目的是为了在事件到达目标元素之前进行一些前置处理。</p>

<p>目标阶段（Target Phase）：
当事件到达目标元素时，即触发了事件的元素本身，进入目标阶段。在目标阶段，目标元素上绑定的事件处理程序被调用。</p>

<p>冒泡传递（Bubbling Phase）：
在冒泡阶段，事件从目标元素开始向上冒泡，依次触发目标元素的父级元素的事件处理程序，直到达到文档根节点。在这个阶段，父级元素的事件处理程序有机会对事件进行响应或进一步处理。</p>

<p>一个例子：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"outer"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"inner"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">"button"</span><span class="nt">&gt;</span>Click me<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">outer</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">outer</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inner</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">outer</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Capture Phase: Outer</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// 使用捕获传递</span>

<span class="nx">inner</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Capture Phase: Inner</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// 使用捕获传递</span>

<span class="nx">button</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Target Phase: Button</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">inner</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bubble Phase: Inner</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span> <span class="c1">// 默认使用冒泡传递</span>

<span class="nx">outer</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bubble Phase: Outer</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span> <span class="c1">// 默认使用冒泡传递</span>
</code></pre></div></div>

<ul>
  <li>点击按钮时</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Capture Phase: Outer
Capture Phase: Inner
Target Phase: Button
Bubble Phase: Inner
Bubble Phase: Outer
</code></pre></div></div>

<p>可以看到，事件首先经过捕获阶段，从外层容器元素（outer）开始，然后逐级向下传递到内层容器元素（inner），最后到达目标元素（button）。接着，事件进入目标阶段，触发了目标元素上的事件处理程序。最后，事件进入冒泡阶段，从内层容器元素（inner）开始向上冒泡，直到外层容器元素（outer）。</p>

<hr />
<hr />

<p>16.css中哪些属性可以继承</p>

<p>A font-size
B margin
C border
D color</p>

<ul>
  <li>答案：ABD</li>
  <li>解析：</li>
</ul>

<p>A. font-size（字体大小）：子元素会继承父元素的字体大小，除非子元素自身定义了自己的字体大小。</p>

<p>B. margin（外边距）：垂直方向的外边距（margin-top、margin-bottom）会被子元素继承。水平方向的外边距（margin-left、margin-right）不会被继承。</p>

<p>D. color（文本颜色）：子元素会继承父元素的文本颜色，除非子元素自身定义了自己的文本颜色。</p>

<p>所以，选项 A、B、D 中的属性可以被继承，而选项 C 中的 border（边框）属性不会被继承。</p>

<hr />
<hr />

<p>17.BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。形成BFC的条件有哪些</p>

<p>A display 为以下其中之一的值 inline-block，table-cell，table-caption、flex
B 浮动元素，float 除 none 以外的值
C overflow 除了 visible 以外的值（hidden，auto，scroll）
D 绝对定位元素，position（absolute，fixed）</p>

<ul>
  <li>答案：ABCD</li>
  <li>
    <p>解析：无</p>
  </li>
  <li>补充：BFC作用</li>
</ul>

<p>清除浮动：当父元素包含浮动元素时，会导致父元素塌陷或无法正确包裹浮动元素。通过创建 BFC，可以使父元素包含浮动元素的高度得到正确计算，从而解决浮动问题。</p>

<p>防止边距重叠：在普通流中，相邻的垂直边距会发生重叠现象，导致边距计算不符合预期。在 BFC 中，垂直边距会被隔离，不会重叠。</p>

<p>自适应两栏布局：通过在容器中创建 BFC，可以使得容器内的两个元素分别处于左右两栏，实现自适应的两栏布局。</p>

<p>阻止文字环绕：当元素浮动时，周围的文字会环绕在其周围。通过创建 BFC，可以阻止文字环绕浮动元素，让其他内容不会受到浮动元素的影响。</p>

<p>控制元素的布局方式：BFC 中的元素按照一定的规则进行布局，例如，块级元素会垂直排列，宽度自动撑开，不与浮动元素重叠等。</p>

<ul>
  <li>补充：什么是浮动元素</li>
</ul>

<p>浮动元素是指通过设置 CSS 属性 float 为除 none 以外的值，使元素脱离正常的文档流，并沿着其容器的左侧或右侧浮动。浮动元素可以向左或向右浮动，周围的内容会环绕在其周围。</p>

<p>浮动元素常用于创建多栏布局、图像排列等情况。当元素浮动时，其宽度会根据内容自动收缩，使得其他元素可以占据其原本的位置。浮动元素会影响其他非浮动元素的布局，导致它们围绕浮动元素重新排列。</p>

<ul>
  <li>补充：高度塌陷</li>
</ul>

<p>高度塌陷（或称为“坍塌”）指的是当一个父元素（容器）包含了浮动元素，并且没有设置明确的高度或清除浮动的机制时，父元素的高度无法正确地包裹其内部的浮动元素，导致父元素的高度变为零或异常小。</p>

<p>高度塌陷的原因是，浮动元素脱离了文档流，不再占据正常的空间，而父元素没有考虑浮动元素的高度，因此无法正确计算父元素的高度。</p>

<hr />
<hr />

<p>18.下列会导致页面回流reflow的操作有哪些</p>

<p>A 添加或者删除可见的DOM元素
B 仅修改DOM元素的字体颜色、背景色
C resize浏览器窗口
D 设置可见元素为display: none
E 读取元素的属性offsetWidth和offsetHeight</p>

<ul>
  <li>
    <p>答案：ADE</p>
  </li>
  <li>
    <p>解析：</p>
  </li>
</ul>

<p>A. 添加或删除可见的 DOM 元素：当添加或删除可见的 DOM 元素时，会影响页面的布局，导致页面回流。</p>

<p>D. 设置可见元素为 display: none：将可见元素的 CSS 属性 display 设置为 none，会导致元素从页面中消失，从而影响整个页面的布局，触发页面回流。</p>

<p>E. 读取元素的属性 offsetWidth 和 offsetHeight：当读取元素的尺寸属性（如 offsetWidth 和 offsetHeight）时，浏览器需要计算元素的大小，并可能触发页面回流。</p>

<p>选项 B（仅修改字体颜色、背景色）和 C（resize 浏览器窗口）不会直接引起页面回流，但可能会触发其他的重绘操作（repaint），从而影响页面的性能。</p>

<ul>
  <li>补充：页面回流</li>
</ul>

<p>页面回流（reflow）是指浏览器为了重新计算元素的几何属性（如位置、尺寸等），而导致整个页面布局发生变化的过程。当页面中的元素发生改变，需要重新计算它们的位置和大小时，浏览器会执行回流操作。</p>

<p>页面回流是一种相对耗费计算资源的操作，因为它需要对页面的每个可见元素进行重新布局计算。当页面中的元素发生变化时，浏览器会进行回流操作来确保元素的几何属性正确计算和渲染。</p>

<hr />
<hr />

<p>19.关于position定位，下列说法正确的是哪些</p>

<p>A absolute的元素，如果它的父容器设置了position属性，并且position的属性值为absolute或者relative，那么就会依据父容器进行偏移
B relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间
C fixed元素，可定位于相对于浏览器窗口的指定坐标，它始终是以 body 为依据
D relative元素是参照父级的原始点为原始点，无父级则以BODY的原始点为原始点，配合TOP、RIGHT、BOTTOM、LEFT进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位</p>

<ul>
  <li>答案：ACD</li>
  <li>解析：</li>
</ul>

<p>absolute 元素能够根据其最近的已定位的祖先元素进行偏移，relative 元素以其原来的位置为基准进行偏移，fixed 元素相对于浏览器窗口进行定位。</p>

<p>relative 元素会参考父级元素的原始点进行定位，如果没有父级元素，则以 body 元素为依据。当父级元素有 padding 等 CSS 属性时，relative 元素的原始点参考的是父级内容区的原始点进行定位。</p>

<p>relative 元素在移动后，仍然占据原来的位置，不会改变其他元素的布局。它的偏移会影响其他元素的位置，但原来的位置仍然会保留，占据空间。</p>

<p>在这里，移动指的是通过设置 relative 元素的偏移属性（如 top、right、bottom、left）来改变其在页面上的位置。</p>

<hr />
<hr />

<p>20.请选择结果为真的表达式</p>

<p>A null instanceof Object
B null === undefined
C null == undefined
D undefined === undefined
E null == null
F null === null</p>

<ul>
  <li>答案：BCEF</li>
  <li>解析：</li>
</ul>

<p>在 JavaScript 中，null 表示一个空值，而 undefined 表示一个未定义的值。</p>

<p>A. null instanceof Object 的结果为假。instanceof 运算符用于检查对象是否属于某个类或构造函数的实例。null 不是任何类或构造函数的实例，因此结果为假。</p>

<p>B. null === undefined 的结果为假。=== 严格相等运算符要求值和类型都相等，null 和 undefined 的类型不同，因此结果为假。</p>

<p>C. null == undefined 的结果为真。== 相等运算符在进行比较时会进行类型转换，null 和 undefined 在进行类型转换后会被视为相等，因此结果为真。</p>

<p>D. undefined === undefined 的结果为真。=== 严格相等运算符要求值和类型都相等，undefined 的类型是 undefined，因此结果为真。</p>

<p>E. null == null 的结果为真。null 和它自身是相等的，因此结果为真。</p>

<p>F. null === null 的结果为真。null 和它自身是严格相等的，因此结果为真。</p>

<hr />
<hr />

<h2 id="编程题">编程题</h2>

<p>21.统计一个字符串出现最多的字母</p>

<p>输入例子：
aab
输出例子：
a</p>

<ul>
  <li>
    <p>哈希表
```py
def find_most_frequent_character(string):
  counter = {}
  max_count = 0
  most_frequent_char = None</p>

    <p>for char in string:
      if char in counter:
          counter[char] += 1
      else:
          counter[char] = 1</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if counter[char] &gt; max_count:
      max_count = counter[char]
      most_frequent_char = char
</code></pre></div>    </div>

    <p>return most_frequent_char, max_count</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
---
---


22.查找字符串中的最长公共前缀

输入例子：
flower,flow,flight
输出例子：
fl
例子说明：
fl为数组中最长公共前缀字符串


</code></pre></div></div>
<p>略</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

--- 
---

23.五八文字碰碰消

  帮帮同学在设计一个文字碰碰消游戏，规定"五"和"八"形成"五八"组合碰到一起即会消除，("八五" 不会消除)。

  例如 "五八", "五八五八", "五五八八"。说明: "五五八八" 是内层的"五八"碰在一起消除后，外层的"五八"会碰在一起消除。

  帮帮同学想知道n个"五"和"八"组成的字符串中，有多少种组合可以满足消除为空字符串。

  现为帮帮同学设计一个方法，输入整数n，表示"五"和"八"的数量，返回n个"五"和n个"八"组成的字符串中，满足消除为空字符串的组合数。


</code></pre></div></div>
<p>输入例子：
2
输出例子：
2
例子说明：
满足的组合  [ ‘五五八八’, ‘五八五八’ ]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

- 力扣22题：括号生成 - 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

</code></pre></div></div>
<p>输入：n = 3
输出：[”((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
---
---


23.




- 思路1：动态规划


第一项必然为左括号，与它匹配的右括号设为第i项，定义它为第1组括号
还剩下n-1组括号，分布在第1组括号的内部或外部
拆分子问题：
( + [i=p时所有括号组合] + ) + [i=q时所有括号组合]
其中 p+q=n-1
p遍历从0到n-1即可包含所有情况

```py
class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        if n == 0:
            return []
        total_l = []
        total_l.append([None])    # 0组括号时记为None
        total_l.append(["()"])    # 1组括号只有一种情况
        for i in range(2,n+1):    # 开始计算i组括号时的括号组合
            l = []        
            for j in range(i):    # 开始遍历 p q ，其中p+q=i-1 , j 作为索引
                now_list1 = total_l[j]    # p = j 时的括号组合情况
                now_list2 = total_l[i-1-j]    # q = (i-1) - j 时的括号组合情况
                for k1 in now_list1:  
                    for k2 in now_list2:
                        if k1 == None:
                            k1 = ""
                        if k2 == None:
                            k2 = ""
                        el = "(" + k1 + ")" + k2
                        l.append(el)    # 把所有可能的情况添加到 l 中
            total_l.append(l)    # l这个list就是i组括号的所有情况，添加到total_l中，继续求解i=i+1的情况
        return total_l[n]
</code></pre></div></div>

<ul>
  <li>官方解法：回溯</li>
</ul>

<p>由暴力遍历法引出</p>

<p>定义函数判断序列是否有效：定义变量balance表示左括号数量减去右括号数量，遍历过程中如果balance小于0 或者结束时balance值不为0，说明序列无效（栈的思想，但并不需要真的定义一个栈）</p>

<p>递归遍历所有可能性：二叉树生成的方法，append左括号之后递归，然后pop，再尝试右括号</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="nf">valid</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
                    <span class="n">ans</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">)</span>
                <span class="nf">generate</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">A</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="n">A</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">)</span>
                <span class="nf">generate</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">A</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="n">bal</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">:</span> <span class="n">bal</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">bal</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">bal</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">bal</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nf">generate</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre></div></div>

<p>↑改善上面的算法可以得到回溯法
并不是列出所有可能性再依次检查valid，而是在原序列有效的前提下再添加一组有效的括号，也就是把valid函数优化掉</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">S</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">(</span><span class="sh">'</span><span class="p">)</span>
                <span class="nf">backtrack</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="n">S</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">S</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">)</span><span class="sh">'</span><span class="p">)</span>
                <span class="nf">backtrack</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">S</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

        <span class="nf">backtrack</span><span class="p">([],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-11-is/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><category term="python" /><summary type="html"><![CDATA[链接：https://www.nowcoder.com/exam/test/74802082/detail?pid=36048429&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26keyword%3D58%E5%90%8C%E5%9F%8E%26selectStatus%3D0&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91]]></summary></entry></feed>