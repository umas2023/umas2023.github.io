<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-10T18:55:19+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">leetcode: 得物笔试</title><link href="/leetcode/js/dewu/" rel="alternate" type="text/html" title="leetcode: 得物笔试" /><published>2023-10-10T17:45:01+08:00</published><updated>2023-10-10T17:45:01+08:00</updated><id>/leetcode/js/dewu</id><content type="html" xml:base="/leetcode/js/dewu/"><![CDATA[<ul>
  <li>接受一个以Promise形式提供的任务列表和一个表示同时发起的任务数量的参数，所有任务完成后把结果按序放入数组返回</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">processTasks</span><span class="p">(</span><span class="nx">taskList</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 执行单个任务</span>
    <span class="k">async</span> <span class="kd">function</span> <span class="nf">runTask</span><span class="p">(</span><span class="nx">task</span><span class="p">,</span> <span class="nx">taskIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">task</span><span class="p">();</span>
        <span class="nx">results</span><span class="p">[</span><span class="nx">taskIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 滑动窗口</span>
    <span class="k">async</span> <span class="kd">function</span> <span class="nf">runTasksInWindow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while </span><span class="p">(</span><span class="nx">currentIndex</span> <span class="o">&lt;</span> <span class="nx">taskList</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">taskIndex</span> <span class="o">=</span> <span class="nx">currentIndex</span><span class="o">++</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">task</span> <span class="o">=</span> <span class="nx">taskList</span><span class="p">[</span><span class="nx">taskIndex</span><span class="p">];</span>
            <span class="k">await</span> <span class="nf">runTask</span><span class="p">(</span><span class="nx">task</span><span class="p">,</span> <span class="nx">taskIndex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 并行任务</span>
    <span class="kd">const</span> <span class="nx">runningTasks</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">runningTasks</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nf">runTasksInWindow</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="nx">runningTasks</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 示例使用</span>

<span class="kd">const</span> <span class="nx">delay</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>

<span class="kd">const</span> <span class="nx">createTask</span> <span class="o">=</span> <span class="p">(</span><span class="nx">taskName</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`starting task </span><span class="p">${</span><span class="nx">taskName</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="nf">delay</span><span class="p">(</span><span class="nx">duration</span><span class="p">).</span><span class="nf">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`complete task </span><span class="p">${</span><span class="nx">taskName</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
            <span class="nf">resolve</span><span class="p">(</span><span class="nx">taskName</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">taskList</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">createTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">task1</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">createTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">task2</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">createTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">task3</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">createTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">task4</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span>
<span class="p">];</span>

<span class="c1">//这段代码是一个立即执行的异步函数表达式（Immediately Invoked Async Function Expression，IIFE）</span>
<span class="c1">// 在这里，定义了一个匿名的异步函数，并立即执行它</span>
<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">processTasks</span><span class="p">(</span><span class="nx">taskList</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
<span class="p">})();</span>
</code></pre></div></div>

<ul>
  <li>调用js</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node.exe .\test.js
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-10-dewu/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="js" /><summary type="html"><![CDATA[接受一个以Promise形式提供的任务列表和一个表示同时发起的任务数量的参数，所有任务完成后把结果按序放入数组返回]]></summary></entry><entry><title type="html">leetcode: 途虎笔试</title><link href="/leetcode/tuhu/" rel="alternate" type="text/html" title="leetcode: 途虎笔试" /><published>2023-10-09T20:33:56+08:00</published><updated>2023-10-09T20:33:56+08:00</updated><id>/leetcode/tuhu</id><content type="html" xml:base="/leetcode/tuhu/"><![CDATA[<ul>
  <li>一般来说hr拿到笔试分数之后不可能去仔细看你的代码</li>
  <li>所以这几道笔试题就显得很弱鸡</li>
  <li>（这几道算法题真的配得上前面的逆天选择题吗）</li>
</ul>

<h2 id="js把秒数格式化为000232格式">js,把秒数格式化为”00:02:32”格式</h2>

<ul>
  <li>这题还好，作为第一题刚刚合适</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">formatTime</span><span class="p">(</span> <span class="nx">seconds</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write code here</span>
    <span class="kd">let</span> <span class="nx">ss</span> <span class="o">=</span> <span class="nx">seconds</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="kd">let</span> <span class="nx">mm</span> <span class="o">=</span>  <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">seconds</span> <span class="o">%</span> <span class="mi">3600</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">hh</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">(</span><span class="nx">seconds</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
    <span class="nx">ss</span> <span class="o">=</span> <span class="nx">ss</span><span class="p">.</span><span class="nf">toString</span><span class="p">().</span><span class="nf">padStart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">mm</span> <span class="o">=</span> <span class="nx">mm</span><span class="p">.</span><span class="nf">toString</span><span class="p">().</span><span class="nf">padStart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">hh</span> <span class="o">=</span> <span class="nx">hh</span><span class="p">.</span><span class="nf">toString</span><span class="p">().</span><span class="nf">padStart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">hh</span><span class="o">+</span><span class="dl">"</span><span class="s2">:</span><span class="dl">"</span><span class="o">+</span><span class="nx">mm</span><span class="o">+</span><span class="dl">"</span><span class="s2">:</span><span class="dl">"</span><span class="o">+</span><span class="nx">ss</span>
<span class="p">}</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">formatTime</span> <span class="p">:</span> <span class="nx">formatTime</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="两字符串str1str2其中str2由str1乱序重排后随机添加一个字符找出这个字符">两字符串str1,str2,其中str2由str1乱序重排后随机添加一个字符，找出这个字符</h2>

<ul>
  <li>这题就完全意义不明</li>
  <li>我选择直接遍历</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findTheDifference</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">str1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">str2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">str2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">str1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">char</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">str1</span> <span class="o">=</span> <span class="n">str1</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="n">char</span><span class="p">,</span><span class="sh">""</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">findTheDifference</span><span class="p">(</span><span class="sh">"</span><span class="s">aa</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">aaa</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="找车胎">找车胎</h2>

<ul>
  <li>题目给了一个场景，从一堆车胎里找胎</li>
  <li>list1是车胎宽度</li>
  <li>list2是宽度对应的数量</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[145,175,215,235],[8,7,2,10]

排序list1
max(list1) = a
找出list2中max所在index对应list1中的数值b
输出[排序list1][a,b]
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">searchTreadWidth</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">treadWidths</span><span class="p">,</span> <span class="n">tireCounts</span><span class="p">):</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="n">treadWidths</span><span class="p">[</span><span class="n">tireCounts</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">tireCounts</span><span class="p">))]</span>
        <span class="n">treadWidthsSort</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">treadWidths</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">treadWidthsSort</span><span class="p">,[</span><span class="n">treadWidthsSort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">maxCount</span><span class="p">]]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">searchTreadWidth</span><span class="p">([</span><span class="mi">155</span><span class="p">,</span><span class="mi">175</span><span class="p">,</span><span class="mi">165</span><span class="p">,</span><span class="mi">195</span><span class="p">,</span><span class="mi">215</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-09-tuhu/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><summary type="html"><![CDATA[一般来说hr拿到笔试分数之后不可能去仔细看你的代码 所以这几道笔试题就显得很弱鸡 （这几道算法题真的配得上前面的逆天选择题吗）]]></summary></entry><entry><title type="html">js: 列表扩展</title><link href="/js/list_unshift/" rel="alternate" type="text/html" title="js: 列表扩展" /><published>2023-10-08T14:39:03+08:00</published><updated>2023-10-08T14:39:03+08:00</updated><id>/js/list_unshift</id><content type="html" xml:base="/js/list_unshift/"><![CDATA[<ul>
  <li>unshift函数扩展列表，三点（扩展运算符）拆分列表</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">show_list</span><span class="p">.</span><span class="nf">unshift</span><span class="p">(...</span><span class="nx">image_urls</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>关于扩展运算符</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">array2</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">array1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="c1">// [1, 2, 3, 4, 5]</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span> <span class="na">x</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">obj1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// { foo: 'bar', x: 42, y: 10 }</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/js/2023-10-08-list_unshift/image_1.jpg) -->]]></content><author><name></name></author><category term="js" /><summary type="html"><![CDATA[unshift函数扩展列表，三点（扩展运算符）拆分列表]]></summary></entry><entry><title type="html">vue: 读取router参数</title><link href="/vue/router_parameter/" rel="alternate" type="text/html" title="vue: 读取router参数" /><published>2023-10-08T14:36:17+08:00</published><updated>2023-10-08T14:36:17+08:00</updated><id>/vue/router_parameter</id><content type="html" xml:base="/vue/router_parameter/"><![CDATA[<ul>
  <li>
    <p>vue读取router参数</p>
  </li>
  <li>比如通过这样的链接访问网页：http://localhost:8080/#/home?id_input=10001</li>
  <li>希望读取到id_input的值并赋给变量</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useRouter</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">vue-router</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nf">useRouter</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">router</span><span class="p">.</span><span class="nx">currentRoute</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">id_input</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>在 Vue 3 中，router.currentRoute.value.query 返回的是一个包含查询参数的对象，其中每个查询参数的值是一个字符串数组（string[]）或单个字符串（string）</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">id_input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="p">(</span><span class="nx">router</span><span class="p">.</span><span class="nx">currentRoute</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">id_input</span> <span class="k">as</span> <span class="nx">string</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/vue/2023-10-08-router_parameter/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><summary type="html"><![CDATA[vue读取router参数]]></summary></entry><entry><title type="html">leetcode: 记某鱼笔试的5道题</title><link href="/leetcode/python/duozhuayu/" rel="alternate" type="text/html" title="leetcode: 记某鱼笔试的5道题" /><published>2023-10-06T16:14:24+08:00</published><updated>2023-10-06T16:14:24+08:00</updated><id>/leetcode/python/duozhuayu</id><content type="html" xml:base="/leetcode/python/duozhuayu/"><![CDATA[<ul>
  <li>据说这个公司每年都用这5道，所以不写公司名了</li>
</ul>

<h2 id="1-good-word">1. Good Word</h2>
<p>字符串中出现最多的字符数量m<br />
字符串中出现最少的字符数量n<br />
m/n = 整数且&gt;1
满足条件为Good Word</p>

<ul>
  <li>暴力求解：创建了一个dic，记录所有字母出现的次数</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isGoodWord</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># write code here
</span>        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">letter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dic</span> <span class="k">else</span> <span class="n">dic</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="p">[</span><span class="n">dic</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">dic</span> <span class="p">]</span>
        <span class="n">maxn</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">minn</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxn</span> <span class="o">%</span> <span class="n">minn</span> <span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">maxn</span><span class="o">/</span><span class="n">minn</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">isGoodWord</span><span class="p">(</span><span class="sh">"</span><span class="s">duozhuayu</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="2-升序链表合并">2. 升序链表合并</h2>

<ul>
  <li>
    <p>合并结果仍为升序链表</p>
  </li>
  <li>
    <p>遍历就完了</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">next_node</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span><span class="n">ListNode</span> <span class="o">=</span> <span class="n">next_node</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge_orders</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">ListNode</span> <span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">ListNode</span> <span class="p">)</span> <span class="o">-&gt;</span><span class="n">ListNode</span><span class="p">:</span>
        <span class="c1"># write code here
</span>        <span class="n">ans</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">ans</span>
        <span class="k">while</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="o">&lt;=</span><span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">.</span><span class="nb">next</span>


<span class="n">ln1</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="bp">None</span><span class="p">)))</span>
<span class="n">ln2</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nc">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
<span class="n">ans</span> <span class="o">=</span> <span class="nc">Solution</span><span class="p">().</span><span class="nf">merge_orders</span><span class="p">(</span><span class="n">ln1</span><span class="p">,</span><span class="n">ln2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="3-解压缩字符串">3. 解压缩字符串</h2>
<p>aabb =&gt; a(2)b(2)<br />
aabbaabb =&gt; (a(2)b(2))2<br />
只出现一次的字母不压缩</p>

<ul>
  <li>
    <p>这里我下面写的程序通过率只有60%</p>
  </li>
  <li>暴力求解：创建了一个函数get_cp，返回每个前括号对应的后括号的位置（list形式）</li>
  <li>本来应该在更新字符串时同步更新上面那个list，但有点错位懒得改了，每次循环都调用一遍get_cp</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">decompress</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">compressed_str</span><span class="p">:</span><span class="nb">str</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>        <span class="k">def</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">str_in</span><span class="p">):</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">letter</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="sh">"</span><span class="s">(</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">letter</span> <span class="o">==</span> <span class="sh">"</span><span class="s">)</span><span class="sh">"</span><span class="p">:</span>
                    <span class="n">cp_index</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">cp_index</span>

        <span class="n">cp_index</span> <span class="o">=</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
        <span class="k">while</span> <span class="nf">sum</span><span class="p">(</span><span class="n">cp_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cp</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">cp_index</span><span class="p">)</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">cp</span><span class="p">:</span>
                    <span class="n">multi</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">[</span><span class="n">cp</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">compressed_str</span> <span class="o">=</span> <span class="n">compressed_str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span> <span class="n">compressed_str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">cp</span><span class="p">]</span> <span class="o">*</span><span class="n">multi</span> <span class="o">+</span><span class="n">compressed_str</span><span class="p">[</span><span class="n">cp</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="nf">len</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)]</span>
                    <span class="n">cp_index</span> <span class="o">=</span> <span class="nf">get_cp</span><span class="p">(</span><span class="n">compressed_str</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">compressed_str</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">decompress</span><span class="p">(</span><span class="sh">"</span><span class="s">((a)2(b)2(c)2)2</span><span class="sh">"</span><span class="p">))</span>
<span class="c1"># print(Solution().decompress("((a)2)2"))
</span>
</code></pre></div></div>

<h2 id="4-货架编号">4. 货架编号</h2>
<p>（类似N字排序，但没找到规律，所以还是用了暴力解法）</p>

<p>等边直角三角形，左上起始，逆时针螺旋排序</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 6 5
2 4
3
</code></pre></div></div>

<p>输入三角形维度，输出横向遍历排序结果</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt; 3
&lt;&lt; [1,6,5,2,4,3]
</code></pre></div></div>

<ul>
  <li>
    <p>在本子上写了几圈，没找到统一的规律，决定用暴力解法，新建n维空矩阵，三个函数fill_down、fill_rightup、fill_left分别向三个方向填入数据，循环到填满左上区域为止</p>
  </li>
  <li>
    <p>这里通过率只有85%</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numberOfShelves</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">N</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>        <span class="n">mt</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">fill_down</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="k">def</span> <span class="nf">fill_rightup</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos1</span> <span class="o">-=</span><span class="mi">1</span>
                <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos1</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>    
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="k">def</span> <span class="nf">fill_left</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos1</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">pos2</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="k">while</span> <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">pos1</span><span class="p">][</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">num</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="n">pos2</span> <span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">pos1</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pos2</span><span class="o">&gt;=</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
                    <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
            <span class="n">pos2</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span>
        
        <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">num0</span> <span class="o">=</span> <span class="n">num</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_down</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pos2</span><span class="p">)</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_rightup</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">pos2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span> <span class="o">=</span> <span class="nf">fill_left</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">pos1</span><span class="p">,</span><span class="n">pos2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            

            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">num0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">pos1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos2</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ans</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">numberOfShelves</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>


</code></pre></div></div>

<h2 id="5-bgp树">5. BGP树</h2>
<ul>
  <li>2^N字符串由01构成</li>
  <li>字符串中全为0，节点value设为B</li>
  <li>全1为P</li>
  <li>都有为G</li>
  <li>判定完当前节点后将字符串等分两半继续判定，到字符串无法二分为止</li>
  <li>输出二叉树后序遍历结果</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"10001101"
"PBGBBBGPPPBPGGG"
</code></pre></div></div>

<ul>
  <li>这题显然是有规律可循的，题解里都没给TreeNode定义</li>
  <li>但还是写了个暴力解法</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">val</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span><span class="n">TreeNode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span><span class="n">TreeNode</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">bpg</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">s</span> <span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">def</span> <span class="nf">bpg_str</span><span class="p">(</span><span class="n">bpgs</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">判断BPG</span><span class="sh">'''</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">bpgs</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">B</span><span class="sh">"</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="sh">"</span><span class="s">0</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">bpgs</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">P</span><span class="sh">"</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">"</span><span class="s">G</span><span class="sh">"</span>
            
        <span class="k">def</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">生成二叉树</span><span class="sh">'''</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span>
            
            <span class="n">tnp</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">bpg_str</span><span class="p">(</span><span class="n">tns</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tnp</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">[:</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)])</span>
                <span class="n">tnp</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">create_tn</span><span class="p">(</span><span class="n">tns</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">tns</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):])</span>
            <span class="k">return</span> <span class="n">tnp</span>
        
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">:</span><span class="n">TreeNode</span><span class="p">):</span>
            <span class="sh">'''</span><span class="s">遍历</span><span class="sh">'''</span>
            <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">''</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="sh">''</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="k">return</span> <span class="nf">traverse</span><span class="p">(</span><span class="nf">create_tn</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">bpg</span><span class="p">(</span><span class="sh">"</span><span class="s">10001101</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-06-duozhuayu/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[据说这个公司每年都用这5道，所以不写公司名了]]></summary></entry><entry><title type="html">python: 开根号</title><link href="/python/sqrt/" rel="alternate" type="text/html" title="python: 开根号" /><published>2023-10-05T19:01:27+08:00</published><updated>2023-10-05T19:01:27+08:00</updated><id>/python/sqrt</id><content type="html" xml:base="/python/sqrt/"><![CDATA[<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 法1：math.sqrt
</span><span class="kn">import</span> <span class="n">math</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># 法2：pow
</span><span class="n">x</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># 法3：**
</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mf">0.5</span>

<span class="c1"># 补充：cmath.sqrt支持复数
</span><span class="kn">import</span> <span class="n">cmath</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cmath</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">#类型为complex
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/python/2023-10-05-sqrt/image_1.jpg) -->]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[```py 法1：math.sqrt import math x = math.sqrt(n)]]></summary></entry><entry><title type="html">leetcode: 完全平方数</title><link href="/leetcode/python/numSquares/" rel="alternate" type="text/html" title="leetcode: 完全平方数" /><published>2023-10-05T17:31:28+08:00</published><updated>2023-10-05T17:31:28+08:00</updated><id>/leetcode/python/numSquares</id><content type="html" xml:base="/leetcode/python/numSquares/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>链接：https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>

<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>

<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 13
输出：2
解释：13 = 4 + 9
</code></pre></div></div>

<h2 id="题解">题解</h2>

<ul>
  <li>难点在于dp矩阵如何构建，以及如何拆分子问题</li>
  <li>设dp[i]表示最少需要多少个数的平方来表示整数i</li>
  <li>遍历[1,i]（实际上只需遍历[1,sqrt(i)]），设当前遍历到j，认为i中拆分出的平方数中包含j，那么只需找到i-j^2包含多少平方数即可，即有dp[i] = 1 + dp[i-j^2]；对于遍历的每一个j都可以得出一个解，其中的最小值即为对i的解</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numSquares</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">minn</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">minn</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">minn</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">])</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">minn</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    
<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">numSquares</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-05-numSquares/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 解决智力问题</title><link href="/leetcode/python/mostPoints/" rel="alternate" type="text/html" title="leetcode: 解决智力问题" /><published>2023-10-05T16:10:23+08:00</published><updated>2023-10-05T16:10:23+08:00</updated><id>/leetcode/python/mostPoints</id><content type="html" xml:base="/leetcode/python/mostPoints/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>链接：https://leetcode.cn/problems/solving-questions-with-brainpower/?envType=study-plan-v2&amp;envId=dynamic-programming</li>
</ul>

<p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [points_i, brainpower_i] 。</p>

<p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  points_i 的分数，但是你将 无法 解决接下来的 brainpower_i 个问题（即只能跳过接下来的 brainpower_i 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p>

<p>比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：<br />
如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。<br />
如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br />
请你返回这场考试里你能获得的 最高 分数。</p>

<h2 id="题解">题解</h2>

<ul>
  <li>dp[i]表示解决前i道问题的最高分数，边界dp[0] = 0，dp[1] = points_0</li>
  <li>类似打家劫舍问题，只不过打劫间隔不是固定的1，而是由brainpower决定</li>
  <li>类比打家劫舍可得dp[i] = max( dp[i-1], dp[i-?]+points_i )，其中dp[i-?]表示满足条件【解决问题i】最近的前一项，（注意满足条件的dp[i-?]可能不只有一项），为找出dp[i-?]可以遍历原数组，找出每一项在删除brainpower后对应的后一项，以此构建索引字典，比如下面的例子</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="c1"># 第0，1，2，3项对应的后一项分别是第3,3,3,4项，因此可以构建字典如下
</span><span class="p">{</span>
    <span class="mi">0</span><span class="p">:[],</span>
    <span class="mi">1</span><span class="p">:[],</span>
    <span class="mi">2</span><span class="p">:[],</span>
    <span class="mi">3</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># index&gt;3没有意义
</span><span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>但显然这样会提高时间复杂度，官方题解采用了另一种思路</li>
  <li>构建状态转移方程的意义在于找出相邻两项dp之间的关系，并不一定是dp[i]和dp[i-1]，也可以是dp[i]和dp[i+1]；我们可以反向思考：</li>
  <li>如果不解决第1道题目，dp[i] = dp[i+1]</li>
  <li>如果解决，下一道题目是<code class="language-plaintext highlighter-rouge">i + brainpower_i + 1</code>，也就是说此时有</li>
</ul>

<center>dp[i] = points_i + dp[i + brainpower_i + 1]</center>

<ul>
  <li>状态转移方程如下</li>
</ul>

<center>dp[i] = max( dp[i+1], points_i + dp[i + brainpower_i + 1] )</center>

<ul>
  <li>此时边界为dp[n] = 0，表示没有做任何题目，所求结果为dp[0]</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">mostPoints</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">questions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">questions</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># 解决每道题及以后题目的最高分数
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">questions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">questions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>因为i + questions[i][1] + 1有可能超出边界，即后面没有可以解的题目，此时可以认为dp[i + brainpower_i + 1] = dp[n] = 0，所以例程中使用了min直接把0赋值给算式</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-05-mostPoints/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">leetcode: 不同的二叉搜索树</title><link href="/leetcode/python/numTrees/" rel="alternate" type="text/html" title="leetcode: 不同的二叉搜索树" /><published>2023-10-05T13:34:41+08:00</published><updated>2023-10-05T13:34:41+08:00</updated><id>/leetcode/python/numTrees</id><content type="html" xml:base="/leetcode/python/numTrees/"><![CDATA[<h2 id="题目">题目</h2>

<ul>
  <li>
    <p>链接：https://leetcode.cn/problems/unique-binary-search-trees/?envType=study-plan-v2&amp;envId=dynamic-programming</p>
  </li>
  <li>
    <p>题目：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：n = 3
输出：5
</code></pre></div></div>

<p><img src="/image/leetcode/2023-10-05-numTrees/image_1.jpg" alt="引入图片" /></p>

<h2 id="题解">题解</h2>

<ul>
  <li>
    <p>首先复习二叉搜索树：左孩子比父节点小，右孩子比父节点大；（中序遍历可以让节点有序）</p>
  </li>
  <li>遍历每个数字 i，将该数字作为树根，将 [1:(i-1)] 序列作为左子树，将[(i+1):n]序列作为右子树</li>
  <li>↑对每个数字i都可以拆分出两个子问题，因此可以考虑使用动态规划</li>
  <li>定义dp[n]为长度为n的序列能构成的不同二叉搜索树的数量，边界为dp[0] = 0；dp[1] = 1</li>
  <li>定义F[i][n]为数字i为根时的。。。二叉树的数量，显然有dp[n] = ΣF[i][n]</li>
  <li>如果能找出F[i][n] = f( dp[n] )的另一个关系，和上式联立就可以得出dp的状态转移方程</li>
  <li>可以从子问题的拆分入手，以i为根节点时的左右子树的数量分别可以表示为dp[i-1]和dp[n-i]，两边子树各的组合数即为F[i][n]，即笛卡尔积；可以表示为：F[i][n] = dp[i-1] × dp[n-i]</li>
  <li>状态转移方程为：dp[n] = Σ( dp[i-1] × dp[n-i] )</li>
</ul>

<blockquote>

  <ul>
    <li>补充：笛卡尔积</li>
    <li>两个集合X和Y的笛卡尔积 (Cartesian product)，又称直积，表示 X x Y，第一个对象是 X 的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</li>
    <li>示例：A = {a,b}, B = {0,1,2}，则<br />
A×B = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}<br />
B×A = {(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}</li>
  </ul>

</blockquote>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numTrees</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type n: int
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">G</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">G</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-10-05-numTrees/image_1.jpg) -->

<h2 id="补充">补充</h2>

<p>上面dp的函数被称为【卡塔兰数Cn】<br />
C0 = 1
C(n+1) = Cn * 2(2n+1)/(n+2)</p>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[题目]]></summary></entry><entry><title type="html">Klook笔试 - 9键输入法组合</title><link href="/leetcode/python/9_button_input/" rel="alternate" type="text/html" title="Klook笔试 - 9键输入法组合" /><published>2023-10-04T20:42:31+08:00</published><updated>2023-10-04T20:42:31+08:00</updated><id>/leetcode/python/9_button_input</id><content type="html" xml:base="/leetcode/python/9_button_input/"><![CDATA[<ul>
  <li>Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题</li>
  <li>简述一下题目大意：9键输入法，给定按键序列，返回所有组合</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>比如按下23
所有可能的组合有['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
</code></pre></div></div>

<ul>
  <li>题目本身不难，循环嵌套再拼接就行了</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dic9</span><span class="o">=</span><span class="p">{</span>
        <span class="sh">"</span><span class="s">2</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">g</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">h</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">i</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">5</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">j</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">k</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">l</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">6</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">m</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">7</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">q</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">8</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">u</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">v</span><span class="sh">"</span><span class="p">],</span>
        <span class="sh">"</span><span class="s">9</span><span class="sh">"</span><span class="p">:[</span><span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">z</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">dic9</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">dic9</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">sv</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">letter</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">sv</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>

</code></pre></div></div>

<ul>
  <li>（但是他妈的，python打印字符串列表时默认使用单引号，牛客判定结果用双引号，我的程序通过率是0%）</li>
  <li>（↑转义成纯字符串也通不过，妈的真是触及到知识盲区了）</li>
</ul>

<!--![引入图片](/image/leetcode/2023-10-04-9_button_input/image_1.jpg) -->

<h2 id="2023105补充">2023.10.5补充</h2>

<ul>
  <li>补充：笛卡尔积</li>
  <li>两个集合X和Y的笛卡尔积 (Cartesian product)，又称直积，表示 X x Y，第一个对象是 X 的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = {a,b}, B = {0,1,2}，则

A×B = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}

B×A = {(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}
</code></pre></div></div>

<ul>
  <li>内置模块itertools</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">))</span>

<span class="c1"># 示例用法
</span><span class="n">set1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">set3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(1, 'a', True), (1, 'a', False), (1, 'b', True), (1, 'b', False), (1, 'c', True), (1, 'c', False), (2, 'a', True), (2, 'a', False), (2, 'b', True), (2, 'b', False), (2, 'c', True), (2, 'c', False)]
</code></pre></div></div>

<ul>
  <li>稍微修改上面的代码就可以得到题目要求的结果</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 示例用法
</span><span class="n">set1</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set2</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">]</span>
<span class="n">set3</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">set3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['ace', 'acf', 'ade', 'adf', 'bce', 'bcf', 'bde', 'bdf']
</code></pre></div></div>]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[Klook笔试题，因为原题是英文给的，事后没有找到完全一样的原题 简述一下题目大意：9键输入法，给定按键序列，返回所有组合]]></summary></entry></feed>