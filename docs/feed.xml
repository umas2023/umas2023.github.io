<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-30T19:44:31+08:00</updated><id>/feed.xml</id><title type="html">umas’ awesome title</title><subtitle>umas&apos; awesome description for his new site here. It will appear in his document head meta (for Google search results) and in his feed.xml site description.</subtitle><entry><title type="html">vue: ref替代querySelector</title><link href="/vue/js/querySelector_ref/" rel="alternate" type="text/html" title="vue: ref替代querySelector" /><published>2023-11-30T14:23:09+08:00</published><updated>2023-11-30T14:23:09+08:00</updated><id>/vue/js/querySelector_ref</id><content type="html" xml:base="/vue/js/querySelector_ref/"><![CDATA[<ul>
  <li>这样一个场景</li>
  <li>子组件CollapseBlock中用querySelector选中div后修改了属性</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"header-arrow"</span> <span class="na">style=</span><span class="s">"margin-left: 5px;"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arrow_element</span> <span class="o">=</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#header-arrow</span><span class="dl">"</span><span class="p">)</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">)</span>
<span class="nx">arrow_element</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">rotate(90deg)</span><span class="dl">"</span>
<span class="p">...</span>
</code></pre></div></div>

<ul>
  <li>
    <p>父组件中用v-for循环了多个子组件，发现被修改的属性始终只有循环第一个元素，因为document.querySelector默认在整个dom中查找</p>
  </li>
  <li>
    <p>可以用vue的ref替代</p>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"header-arrow"</span> <span class="na">ref=</span><span class="s">"arrow_element"</span> <span class="na">style=</span><span class="s">"margin-left: 5px;"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arrow_element</span> <span class="o">=</span> <span class="nf">ref</span><span class="p">()</span>
<span class="nx">arrow_element</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">rotate(90deg)</span><span class="dl">"</span>
</code></pre></div></div>

<ul>
  <li>此时对arrow_element的引用是独一无二的</li>
</ul>

<!--![引入图片](/image/vue/2023-11-30-querySelector_ref/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><summary type="html"><![CDATA[这样一个场景 子组件CollapseBlock中用querySelector选中div后修改了属性]]></summary></entry><entry><title type="html">css: height:auto的元素改变高度时适用transition</title><link href="/css/height_transition/" rel="alternate" type="text/html" title="css: height:auto的元素改变高度时适用transition" /><published>2023-11-30T13:12:22+08:00</published><updated>2023-11-30T13:12:22+08:00</updated><id>/css/height_transition</id><content type="html" xml:base="/css/height_transition/"><![CDATA[<ul>
  <li>下面这个例子里height从auto改变到0时是不能触发transition: 0.5s的过渡动画的</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span><span class="nc">.block-body</span> <span class="p">{</span>
    <span class="nl">height</span><span class="p">:</span><span class="nb">auto</span><span class="p">;</span>
    <span class="nl">transition</span><span class="p">:</span> <span class="m">0.5s</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">div</span><span class="nc">.block-body.hide</span> <span class="p">{</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>一个小trick，用max-height替代height，设置一个很大的初值像这样：</li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">div</span><span class="nc">.block-body</span> <span class="p">{</span>
    <span class="nl">transition</span><span class="p">:</span> <span class="m">0.5s</span><span class="p">;</span>
    <span class="nl">max-height</span><span class="p">:</span> <span class="m">1000px</span><span class="p">;</span>
    <span class="nl">overflow-y</span><span class="p">:</span> <span class="nb">auto</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">div</span><span class="nc">.block-body.hide</span> <span class="p">{</span>
    <span class="nl">max-height</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>就可以有过渡动画效果了</li>
  <li>但有一个小问题，实际上0.5s被分配给1000px~0px的变化过程中，但实际auto~0px会小于1000，页面上变化的视觉效果并不是0.5s，这个小技巧只适用于对动效精度要求不高的场合</li>
  <li>（不然就用js）</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/css/2023-11-30-height_transition/image_1.jpg) -->]]></content><author><name></name></author><category term="css" /><summary type="html"><![CDATA[下面这个例子里height从auto改变到0时是不能触发transition: 0.5s的过渡动画的]]></summary></entry><entry><title type="html">tampermonkey: docin白嫖下载</title><link href="/tampermonkey/js/canvas_save/" rel="alternate" type="text/html" title="tampermonkey: docin白嫖下载" /><published>2023-11-28T19:37:21+08:00</published><updated>2023-11-28T19:37:21+08:00</updated><id>/tampermonkey/js/canvas_save</id><content type="html" xml:base="/tampermonkey/js/canvas_save/"><![CDATA[<ul>
  <li>docin上看到ok的文章之后发现果然需要付费下载</li>
  <li>（你都在网页上给我看了还想限制我下载？）</li>
  <li>F12发现果然是放在canvas里的图片，关于canvas早就想了解一下了，正好今天比较闲，决定找gpt学一学</li>
</ul>

<h2 id="canvas下载基本原理">canvas下载基本原理</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取具有 class="hkswf-content2" 的 &lt;div&gt; 元素</span>
<span class="kd">const</span> <span class="nx">divElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.hkswf-content2</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 在 &lt;div&gt; 元素内查找 &lt;canvas&gt; 元素</span>
<span class="kd">const</span> <span class="nx">canvasElement</span> <span class="o">=</span> <span class="nx">divElement</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">canvas</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 将画布内容转换为数据 URL</span>
<span class="kd">const</span> <span class="nx">dataURL</span> <span class="o">=</span> <span class="nx">canvasElement</span><span class="p">.</span><span class="nf">toDataURL</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>
    <p>上面的脚本可以直接在console里敲，获取到的dataURL是一个以data:image/png;base64开头的非常长的数据（其实就是图片）</p>
  </li>
  <li>
    <p>另存为test.txt，使用py脚本把它转化为图片</p>
  </li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">base64</span>
<span class="c1"># 读取文本文件中的数据 URL
</span><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">./test.txt</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="n">data_url</span> <span class="o">=</span> <span class="nb">file</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
<span class="c1"># 确定数据 URL 的格式（例如："data:image/png;base64"）
</span><span class="nb">format</span><span class="p">,</span> <span class="n">encoded_data</span> <span class="o">=</span> <span class="n">data_url</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># 解码 Base64 编码的数据
</span><span class="n">decoded_data</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">b64decode</span><span class="p">(</span><span class="n">encoded_data</span><span class="p">)</span>
<span class="c1"># 提取文件名（可根据需要进行自定义命名）
</span><span class="n">filename</span> <span class="o">=</span> <span class="sh">"</span><span class="s">image.png</span><span class="sh">"</span>  <span class="c1"># 文件名为 image.png，你可以根据需要修改
# 以二进制模式写入解码后的数据到本地文件
</span><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">'</span><span class="s">wb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="nb">file</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">decoded_data</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">图像已保存为</span><span class="sh">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>可以看到图片已经被成功下载了，下面把这些步骤集成在一个tampermonkey脚本里</li>
</ul>

<h2 id="tampermonkey基本框架和主要函数">tampermonkey基本框架和主要函数</h2>

<ul>
  <li>首先是一个简单的框架，获取页面所有的canvas元素，设计的使用方法是直接在console里敲函数，所以把主函数getAllCanvases挂在window上，这样就可以直接在console里使用这个函数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ==UserScript==</span>
<span class="c1">// @name         获取所有 canvas 对象</span>
<span class="c1">// @namespace    tampermonkey-example</span>
<span class="c1">// @version      1.0</span>
<span class="c1">// @description  获取指定目标网站上的所有 canvas 对象</span>
<span class="c1">// @match        https://www.docin.com/*</span>
<span class="c1">// @grant        none</span>
<span class="c1">// ==/UserScript==</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

    <span class="c1">// 获取所有 canvas 对象的函数</span>
    <span class="kd">function</span> <span class="nf">getAllCanvases</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">canvases</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">canvas</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">canvases</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 将 getAllCanvases 函数绑定到 window 对象上</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">getAllCanvases</span> <span class="o">=</span> <span class="nx">getAllCanvases</span><span class="p">;</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">加载用户脚本</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">提供函数：getAllCanvases</span><span class="dl">"</span><span class="p">);</span>
<span class="p">})();</span>
</code></pre></div></div>

<ul>
  <li>为了把资源保存到本地，还需要一个保存的函数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 将 canvas 对象的内容保存为文本文件</span>
<span class="kd">function</span> <span class="nf">saveCanvasToTextFile</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">dataURL</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">toDataURL</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">fileName</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.txt</span><span class="dl">'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Blob</span><span class="p">([</span><span class="nx">dataURL</span><span class="p">],</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span> <span class="p">});</span>

    <span class="c1">// 创建下载链接</span>
    <span class="kd">var</span> <span class="nx">downloadLink</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">downloadLink</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nf">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>
    <span class="nx">downloadLink</span><span class="p">.</span><span class="nx">download</span> <span class="o">=</span> <span class="nx">fileName</span><span class="p">;</span>

    <span class="c1">// 模拟点击下载链接</span>
    <span class="nx">downloadLink</span><span class="p">.</span><span class="nf">click</span><span class="p">();</span>

    <span class="c1">// 释放资源</span>
    <span class="nx">URL</span><span class="p">.</span><span class="nf">revokeObjectURL</span><span class="p">(</span><span class="nx">downloadLink</span><span class="p">.</span><span class="nx">href</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>但实际上直接在js里把资源保存为png更加简单方便</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">saveCanvasToImage</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">dataURL</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">toDataURL</span><span class="p">(</span><span class="dl">'</span><span class="s1">image/png</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fileName</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.png</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 创建下载链接</span>
<span class="kd">var</span> <span class="nx">downloadLink</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">downloadLink</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">dataURL</span><span class="p">;</span>
<span class="nx">downloadLink</span><span class="p">.</span><span class="nx">download</span> <span class="o">=</span> <span class="nx">fileName</span><span class="p">;</span>

<span class="c1">// 模拟点击下载链接</span>
<span class="nx">downloadLink</span><span class="p">.</span><span class="nf">click</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="完整脚本">完整脚本</h2>

<ul>
  <li>上面的脚本有一个问题，实际上网页中的图片是懒加载的，并且当图片移出可视区域时资源会被回收</li>
  <li>所以至少要从头到尾滚动一次，在新的canvas出现时读取它并存入一个全局变量中，并且需要一个合理的去重函数</li>
  <li>（由于 canvas 对象是 JavaScript 中的对象类型，即使两个 canvas 对象的内容相同，它们在内存中也是不同的对象，因此无法直接使用 includes 方法进行准确的去重）</li>
  <li>如果每个canvas都有独立的id的话就很简单了，直接用canvas.id即可去重，但显然没有；观察网页结构发现canvas的第5级父元素有独立的id，把它作为去重的依据</li>
  <li>
    <p>绑定鼠标滚动事件刷新allCanvases列表</p>
  </li>
  <li>以下是完整脚本</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ==UserScript==</span>
<span class="c1">// @name         获取docin所有懒加载的 canvas 对象并保存为图像文件</span>
<span class="c1">// @namespace    tampermonkey-example</span>
<span class="c1">// @version      1.0</span>
<span class="c1">// @description  获取指定目标网站上的所有懒加载的 canvas 对象，并将内容保存为以序号命名的图像文件（PNG格式）</span>
<span class="c1">// @match        https://www.docin.com/*</span>
<span class="c1">// @grant        none</span>
<span class="c1">// ==/UserScript==</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">加载用户脚本</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">提供函数：saveAllCanvases</span><span class="dl">"</span><span class="p">);</span>

    <span class="c1">// 存储所有 canvas 对象的全局变量</span>
    <span class="kd">var</span> <span class="nx">allCanvases</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">// 存储所有 canvas 对象对应的第5级父元素的id的辅助数组</span>
    <span class="kd">var</span> <span class="nx">parentIds</span> <span class="o">=</span> <span class="p">[];</span>


    <span class="c1">// 获取所有 canvas 对象的函数</span>
    <span class="kd">function</span> <span class="nf">getAllCanvases</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">canvases</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">canvas</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">canvases</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 将 canvas 对象的内容保存为图像文件（PNG格式）</span>
    <span class="kd">function</span> <span class="nf">saveAllCanvases</span><span class="p">(){</span>
        <span class="kd">function</span> <span class="nf">saveCanvasToImage</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">dataURL</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nf">toDataURL</span><span class="p">(</span><span class="dl">'</span><span class="s1">image/png</span><span class="dl">'</span><span class="p">);</span>
            <span class="kd">var</span> <span class="nx">fileName</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">.png</span><span class="dl">'</span><span class="p">;</span>

            <span class="c1">// 创建下载链接</span>
            <span class="kd">var</span> <span class="nx">downloadLink</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
            <span class="nx">downloadLink</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="nx">dataURL</span><span class="p">;</span>
            <span class="nx">downloadLink</span><span class="p">.</span><span class="nx">download</span> <span class="o">=</span> <span class="nx">fileName</span><span class="p">;</span>

            <span class="c1">// 模拟点击下载链接</span>
            <span class="nx">downloadLink</span><span class="p">.</span><span class="nf">click</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nx">allCanvases</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">saveCanvasToImage</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">saveAllCanvases</span> <span class="o">=</span> <span class="nx">saveAllCanvases</span>




    <span class="c1">// 初始化，获取当前可见的 canvas 对象并存储在全局变量中</span>
    <span class="nx">allCanvases</span> <span class="o">=</span> <span class="nf">getAllCanvases</span><span class="p">();</span>
    <span class="nx">parentIds</span> <span class="o">=</span> <span class="nx">allCanvases</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getCanvasParentId</span><span class="p">(</span><span class="nx">canvas</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// 手动滚动页面时触发的事件处理函数</span>
    <span class="kd">function</span> <span class="nf">handleScrollEvent</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 延迟一段时间等待页面加载</span>
        <span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// 获取新的 canvas 对象</span>
            <span class="kd">var</span> <span class="nx">newCanvases</span> <span class="o">=</span> <span class="nf">getAllCanvases</span><span class="p">();</span>

            <span class="c1">// 合并新获取的 canvas 对象并去除重复项</span>
            <span class="nx">newCanvases</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">newCanvas</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">parentId</span> <span class="o">=</span> <span class="nf">getCanvasParentId</span><span class="p">(</span><span class="nx">newCanvas</span><span class="p">);</span>
                <span class="kd">var</span> <span class="nx">existingIndex</span> <span class="o">=</span> <span class="nx">parentIds</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">parentId</span><span class="p">);</span>

                <span class="k">if </span><span class="p">(</span><span class="nx">existingIndex</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">allCanvases</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">newCanvas</span><span class="p">);</span>
                    <span class="nx">parentIds</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">parentId</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">更新全局变量中的 canvas 对象:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">allCanvases</span><span class="p">);</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">更新辅助数组中的父元素id:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">parentIds</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">300</span><span class="p">);</span> <span class="c1">// 可根据需要调整延迟时间</span>
    <span class="p">}</span>


    <span class="c1">// 获取 canvas 父级元素的 id（向上5级，用于去重）</span>
    <span class="kd">function</span> <span class="nf">getCanvasParentId</span><span class="p">(</span><span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">;</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 监听页面滚动事件</span>
    <span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">scroll</span><span class="dl">'</span><span class="p">,</span> <span class="nx">handleScrollEvent</span><span class="p">);</span>


<span class="p">})();</span>
</code></pre></div></div>

<h2 id="使用说明">使用说明</h2>

<ul>
  <li>添加脚本</li>
  <li>进入网页后鼠标滚动页面直至所有图片都被加载一次（推荐打开F12终端查看是否成功载入）</li>
  <li>F12终端调用函<code class="language-plaintext highlighter-rouge">saveAllCanvases()</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<!--![引入图片](/image/tampermonkey/2023-11-28-canvas_save/image_1.jpg) -->]]></content><author><name></name></author><category term="tampermonkey" /><category term="js" /><summary type="html"><![CDATA[docin上看到ok的文章之后发现果然需要付费下载 （你都在网页上给我看了还想限制我下载？） F12发现果然是放在canvas里的图片，关于canvas早就想了解一下了，正好今天比较闲，决定找gpt学一学]]></summary></entry><entry><title type="html">python: 将变量嵌入字符串的几种方法</title><link href="/python/string_format/" rel="alternate" type="text/html" title="python: 将变量嵌入字符串的几种方法" /><published>2023-11-27T14:13:45+08:00</published><updated>2023-11-27T14:13:45+08:00</updated><id>/python/string_format</id><content type="html" xml:base="/python/string_format/"><![CDATA[<ul>
  <li>百分号法（Percent Formatting）/旧式字符串格式化（Old-style String Formatting）</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">title</span> <span class="o">=</span> <span class="sh">"'</span><span class="s">%s: 将变量嵌入字符串的几种方法</span><span class="sh">'"</span> <span class="o">%</span> <span class="n">basic_cat</span>
</code></pre></div></div>

<ul>
  <li>f-strings（格式化字符串字面值）</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basic_cat</span> <span class="o">=</span> <span class="sh">"</span><span class="s">面试</span><span class="sh">"</span>
<span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">basic_cat</span><span class="si">}</span><span class="s">: 记某面试手搓promise.all</span><span class="sh">"</span>
</code></pre></div></div>

<ul>
  <li>使用字符串的 format 方法</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basic_cat</span> <span class="o">=</span> <span class="sh">"</span><span class="s">面试</span><span class="sh">"</span>
<span class="n">message</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{}: 记某面试手搓promise.all</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">basic_cat</span><span class="p">)</span>
<span class="n">message</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{0}: 记某面试手搓promise.all</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">basic_cat</span><span class="p">)</span>
<span class="n">message</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{category}: 记某面试手搓promise.all</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">basic_cat</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>好的剩下的我们以后遇到再补充</li>
</ul>

<!--![引入图片](/image/python/2023-11-27-string_format/image_1.jpg) -->]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[百分号法（Percent Formatting）/旧式字符串格式化（Old-style String Formatting）]]></summary></entry><entry><title type="html">js: 记某面试手搓promise.all</title><link href="/js/promise_all/" rel="alternate" type="text/html" title="js: 记某面试手搓promise.all" /><published>2023-11-27T14:10:53+08:00</published><updated>2023-11-27T14:10:53+08:00</updated><id>/js/promise_all</id><content type="html" xml:base="/js/promise_all/"><![CDATA[<p>Promise.all 是 JavaScript 中的一个方法，它接收一个 Promise 对象的可迭代数组，并返回一个新的 Promise 对象。这个新的 Promise 对象会在数组中的所有 Promise 对象都已成功解析（resolved）时才会解析，否则会在遇到第一个被拒绝（rejected）的 Promise 对象时被拒绝。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span>
</code></pre></div></div>

<p>其中，iterable 是一个可迭代对象（如数组或类数组对象），包含了多个 Promise 对象。</p>

<p>使用 Promise.all 可以同时处理多个异步操作，并等待它们全部完成后进行进一步的处理。当所有的 Promise 都成功解析时，Promise.all 返回的 Promise 对象会以一个包含了所有 Promise 解析值的数组进行解析。如果任何一个 Promise 被拒绝，Promise.all 返回的 Promise 对象会立即被拒绝，并带有被拒绝的 Promise 的原因。
下面是一个使用 Promise.all 的示例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 1 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 2 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 3 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1500</span><span class="p">);</span>
<span class="p">});</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">then</span><span class="p">((</span><span class="nx">results</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span> <span class="c1">// ["Promise 1 resolved", "Promise 2 resolved", "Promise 3 resolved"]</span>
    <span class="c1">// 所有 Promise 都已成功解析</span>
<span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span> <span class="c1">// 如果有任何一个 Promise 被拒绝</span>
<span class="p">});</span>

</code></pre></div></div>

<p>在上述示例中，Promise.all 接收一个包含了三个 Promise 对象的数组。当这三个 Promise 都成功解析后，.then 部分会被执行，并打印出包含了所有 Promise 解析值的数组。如果有任何一个 Promise 被拒绝，.catch 部分会被执行，并打印出被拒绝的 Promise 的原因。</p>

<p>以下是一个简单的示例，演示如何自己实现 Promise.all 方法：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">myPromiseAll</span><span class="p">(</span><span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">completedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 检查参数是否为可迭代对象</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span> <span class="k">in</span> <span class="nx">promises</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">reject</span><span class="p">(</span><span class="k">new</span> <span class="nc">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">promises must be an iterable</span><span class="dl">'</span><span class="p">));</span>
<span class="p">}</span>
    <span class="c1">// 遍历所有 Promise 对象</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">.</span><span class="nf">then</span><span class="p">((</span><span class="nx">result</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
          <span class="nx">completedCount</span><span class="o">++</span><span class="p">;</span>
          <span class="c1">// 当所有 Promise 都已成功解析时，解析返回的 Promise</span>
          <span class="k">if </span><span class="p">(</span><span class="nx">completedCount</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">resolve</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 如果有一个 Promise 被拒绝，立即拒绝返回的 Promise</span>
<span class="nf">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// 示例用法</span>
<span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 1 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 2 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">});</span>
<span class="kd">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise 3 resolved</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1500</span><span class="p">);</span>
<span class="p">});</span>
<span class="nf">myPromiseAll</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">then</span><span class="p">((</span><span class="nx">results</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span> <span class="c1">// ["Promise 1 resolved", "Promise 2 resolved", "Promise 3 resolved"]</span>
    <span class="c1">// 所有 Promise 都已成功解析</span>
<span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span> <span class="c1">// 如果有任何一个 Promise 被拒绝</span>
<span class="p">});</span>

</code></pre></div></div>

<!--![引入图片](/image/js/2023-11-27-promise_all/image_1.jpg) -->]]></content><author><name></name></author><category term="js" /><summary type="html"><![CDATA[Promise.all 是 JavaScript 中的一个方法，它接收一个 Promise 对象的可迭代数组，并返回一个新的 Promise 对象。这个新的 Promise 对象会在数组中的所有 Promise 对象都已成功解析（resolved）时才会解析，否则会在遇到第一个被拒绝（rejected）的 Promise 对象时被拒绝。]]></summary></entry><entry><title type="html">js: 异步优先级</title><link href="/js/async_priority/" rel="alternate" type="text/html" title="js: 异步优先级" /><published>2023-11-27T14:03:54+08:00</published><updated>2023-11-27T14:03:54+08:00</updated><id>/js/async_priority</id><content type="html" xml:base="/js/async_priority/"><![CDATA[<ul>
  <li>JavaScript中的异步操作具有不同的优先级，这取决于异步操作的类型和调用方式。下面列出了常见的异步操作及其优先级：
    <ol>
      <li>宏任务（Macrotasks）：宏任务包括整体代码块（script），setTimeout、setInterval、setImmediate（Node.js环境中），I/O 操作等。宏任务具有较低的优先级，当执行栈为空时才会执行。</li>
      <li>微任务（Microtasks）：微任务包括Promise、MutationObserver、process.nextTick（Node.js环境中）等。微任务拥有较高的优先级，会在当前宏任务执行结束后、下一个宏任务开始之前执行。</li>
    </ol>
  </li>
  <li>综合来说，JavaScript的异步操作按照以下顺序执行：
    <ol>
      <li>执行当前的同步代码，直到遇到第一个宏任务。</li>
      <li>执行所有微任务队列中的任务，直到微任务队列为空。</li>
    </ol>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">().</span><span class="nf">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">4</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// 结果1432</span>
</code></pre></div></div>

<p>在这个例子中，首先会执行同步代码，并按顺序打印出1和4。然后，setTimeout函数会被调度为一个宏任务，但由于延时为0，所以会被放入宏任务队列中等待执行。接下来，Promise.resolve().then会被调度为一个微任务，并立即执行，打印出3。最后，当所有的同步代码执行完毕后，事件循环会开始执行下一个宏任务，此时会打印出2。</p>

<!--![引入图片](/image/js/2023-11-27-async_priority/image_1.jpg) -->]]></content><author><name></name></author><category term="js" /><summary type="html"><![CDATA[JavaScript中的异步操作具有不同的优先级，这取决于异步操作的类型和调用方式。下面列出了常见的异步操作及其优先级： 宏任务（Macrotasks）：宏任务包括整体代码块（script），setTimeout、setInterval、setImmediate（Node.js环境中），I/O 操作等。宏任务具有较低的优先级，当执行栈为空时才会执行。 微任务（Microtasks）：微任务包括Promise、MutationObserver、process.nextTick（Node.js环境中）等。微任务拥有较高的优先级，会在当前宏任务执行结束后、下一个宏任务开始之前执行。 综合来说，JavaScript的异步操作按照以下顺序执行： 执行当前的同步代码，直到遇到第一个宏任务。 执行所有微任务队列中的任务，直到微任务队列为空。]]></summary></entry><entry><title type="html">vue: 拷贝按钮-点击复制文本到剪贴板</title><link href="/vue/js/clipboard/" rel="alternate" type="text/html" title="vue: 拷贝按钮-点击复制文本到剪贴板" /><published>2023-11-27T13:52:27+08:00</published><updated>2023-11-27T13:52:27+08:00</updated><id>/vue/js/clipboard</id><content type="html" xml:base="/vue/js/clipboard/"><![CDATA[<ul>
  <li>实现方法:document.execCommand(“copy”);</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textarea</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">textarea</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">textarea</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ccccccccccccccc</span><span class="dl">"</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">textarea</span><span class="p">);</span>
<span class="nx">textarea</span><span class="p">.</span><span class="nf">select</span><span class="p">();</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">execCommand</span><span class="p">(</span><span class="dl">"</span><span class="s2">copy</span><span class="dl">"</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">textarea</span><span class="p">);</span>
<span class="nf">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">已复制到剪贴板</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>这是以前用过的一个其他方法，也记录一下</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// npm install vue-clipboard3</span>

<span class="k">import</span> <span class="nx">useClipboard</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">vue-clipboard3</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 复制到剪贴板</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">toClipboard</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">useClipboard</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">copyCode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">toClipboard</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">ElMessage</span><span class="p">.</span><span class="nf">success</span><span class="p">({</span>
    <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">编码已复制到剪贴板</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<!--![引入图片](/image/vue/2023-11-27-clipboard/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><summary type="html"><![CDATA[实现方法:document.execCommand(“copy”);]]></summary></entry><entry><title type="html">vue: 使用fetch动态获取本地json文件</title><link href="/vue/js/fetch_json/" rel="alternate" type="text/html" title="vue: 使用fetch动态获取本地json文件" /><published>2023-11-27T13:46:29+08:00</published><updated>2023-11-27T13:46:29+08:00</updated><id>/vue/js/fetch_json</id><content type="html" xml:base="/vue/js/fetch_json/"><![CDATA[<ul>
  <li>一般来说直接在头部import就可以导入json像这样</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">image_list</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/assets/list/image_list.json</span><span class="dl">"</span>
</code></pre></div></div>

<ul>
  <li>但如果需要在函数里动态导入json，可以使用fetch</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">json_url</span> <span class="o">=</span> <span class="nx">xxx</span>
<span class="nf">fetch</span><span class="p">(</span><span class="nx">json_url</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">())</span>
    <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">res_text</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">input_id</span><span class="p">.</span><span class="nx">value</span>
        <span class="nx">res_json</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">data</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">res_json</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error fetching JSON:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div></div>

<!--![引入图片](/image/vue/2023-11-27-fetch_json/image_1.jpg) -->]]></content><author><name></name></author><category term="vue" /><category term="js" /><summary type="html"><![CDATA[一般来说直接在头部import就可以导入json像这样]]></summary></entry><entry><title type="html">leetcode: 链表倒数第n项</title><link href="/leetcode/python/list_nth/" rel="alternate" type="text/html" title="leetcode: 链表倒数第n项" /><published>2023-11-27T13:43:42+08:00</published><updated>2023-11-27T13:43:42+08:00</updated><id>/leetcode/python/list_nth</id><content type="html" xml:base="/leetcode/python/list_nth/"><![CDATA[<ul>
  <li>使用双指针法查找链表的倒数第n项</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>


<span class="k">def</span> <span class="nf">get_nth_from_end</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># 初始化两个指针
</span>    <span class="n">slow</span> <span class="o">=</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>

    <span class="c1"># 将fast指针向前移动n个节点
</span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fast</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># 链表长度小于n，不存在倒数第n项
</span>        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>

    <span class="c1"># 同时移动slow和fast指针，直到fast指针到达链表尾部
</span>    <span class="k">while</span> <span class="n">fast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>

    <span class="k">return</span> <span class="n">slow</span>


<span class="c1"># 示例链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
</span><span class="n">head</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># 获取倒数第2项
</span><span class="n">result</span> <span class="o">=</span> <span class="nf">get_nth_from_end</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">th element from the end is: </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="n">val</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Invalid input or the list length is less than </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<!--![引入图片](/image/leetcode/2023-11-27-list_nth/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><summary type="html"><![CDATA[使用双指针法查找链表的倒数第n项]]></summary></entry><entry><title type="html">leetcode: 理想复活赛笔试</title><link href="/leetcode/python/js/lixiang/" rel="alternate" type="text/html" title="leetcode: 理想复活赛笔试" /><published>2023-11-03T15:28:17+08:00</published><updated>2023-11-03T15:28:17+08:00</updated><id>/leetcode/python/js/lixiang</id><content type="html" xml:base="/leetcode/python/js/lixiang/"><![CDATA[<ul>
  <li>虽然被捞起来打复活赛，但明显这个部门需要的不是我，选择题基本没有会的，算法两个c的内存调度也没写</li>
  <li>只记录两道py</li>
</ul>

<h2 id="知识总结">知识总结</h2>

<ul>
  <li>最小堆</li>
  <li>DFS/BFS</li>
</ul>

<h2 id="返回数组第k大">返回数组第k大</h2>

<ul>
  <li>提交的代码显然不是考官希望看到的</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="n">self</span> <span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">nums</span><span class="p">)[</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">findKthLargest</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>这里补充一个之前准备前端面试时候的解法（js），构建一个最小堆</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 找出数组中第k大的元素，用堆实现</span>

<span class="c1">// 遍历数组 nums 中的每个元素，并将其插入到最小堆中。如果堆的大小超过了 k，则移除堆顶元素，以确保堆的大小不超过 k。</span>
<span class="c1">//最后，我们返回堆顶元素，即为数组中第 k 大的元素。</span>
<span class="kd">function</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建一个最小堆</span>
    <span class="kd">const</span> <span class="nx">minHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MinHeap</span><span class="p">();</span>
    <span class="c1">// 将数组元素插入最小堆</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">minHeap</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="c1">// 如果堆的大小超过 k，则移除堆顶元素</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">minHeap</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">minHeap</span><span class="p">.</span><span class="nf">remove</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 返回堆顶元素，即为第 k 大元素</span>
    <span class="k">return</span> <span class="nx">minHeap</span><span class="p">.</span><span class="nf">peek</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 最小堆类定义</span>
<span class="c1">// 最小堆（Min Heap）是一种二叉堆，它是一种特殊的完全二叉树结构，其中每个父节点的值都小于或等于其子节点的值。换句话说，最小堆中的最小值存储在根节点，并且对于堆中的任意节点，其值都小于或等于其子节点的值。</span>
<span class="c1">// 索引为 i 的节点的父节点索引为 (i - 1) / 2，左子节点索引为 2 * i + 1，右子节点索引为 2 * i + 2。</span>
<span class="kd">class</span> <span class="nc">MinHeap</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="c1">// 获取堆的大小</span>
    <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 获取堆顶元素</span>
    <span class="nf">peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 插入元素到堆中</span>
    <span class="nf">insert</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nf">heapifyUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 移除堆顶元素</span>
    <span class="nf">remove</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kd">const</span> <span class="nx">removedValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">lastValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lastValue</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyDown</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">removedValue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将元素上移，保持堆的性质(插入元素时)</span>
    <span class="nf">heapifyUp</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">parentIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
            <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]];</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 将元素下移，保持堆的性质（删除元素时）</span>
    <span class="nf">heapifyDown</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">leftChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">rightChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">leftChildIndex</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">leftChildIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">leftChildIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">rightChildIndex</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">rightChildIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">smallestChildIndex</span> <span class="o">=</span> <span class="nx">rightChildIndex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">smallestChildIndex</span> <span class="o">!==</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">smallestChildIndex</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]];</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">heapifyDown</span><span class="p">(</span><span class="nx">smallestChildIndex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">kthLargest</span> <span class="o">=</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">kthLargest</span><span class="p">);</span> <span class="c1">// 输出 6</span>

</code></pre></div></div>

<h2 id="01岛屿连接">01岛屿连接</h2>

<ul>
  <li>
    <p>这题前面某一家前端面试时候问到过，但实际用代码实现之后因为超时没能100%</p>
  </li>
  <li>思路是首先遍历每一项，通过一个check4p子函数迭代检查当前位置的4个方向</li>
  <li>为了防止重复遍历，在子函数中计数过的1都改成2（面试时候面试官提到改成0可能会影响后续的遍历，但现在想想好像也没关系，官方题解给的也是0）</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 最大全1区域
# 求01矩阵中最大的全1连通块的大小
# [[1,1,1,0],[1,1,0,1],[1,0,0,1],[1,1,0,0]]
# 通过率60%，超时
</span>

<span class="c1">#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
#
# @param grid int整型二维数组
# @return int整型
#
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">cur_size</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cur_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">):</span>
            <span class="sh">"""</span><span class="s">迭代检查四个方向</span><span class="sh">"""</span>
            <span class="k">global</span> <span class="n">cur_size</span>

            <span class="nf">if </span><span class="p">(</span>
                <span class="p">(</span><span class="n">pos_x</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_y</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">pos_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> 
            <span class="nf">if </span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cur_size</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">pos_x</span><span class="p">][</span><span class="n">pos_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">check4p</span><span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nf">check4p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">max_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="n">cur_size</span><span class="p">)</span>
                    <span class="n">cur_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">max_size</span>


<span class="nf">print</span><span class="p">(</span><span class="nc">Solution</span><span class="p">().</span><span class="nf">solve</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>

</code></pre></div></div>

<ul>
  <li>笔试时候比较紧张，写法可能不够优雅（global），贴一个gpt的答案</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_largest_ones_block</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">cols</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="ow">or</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">max_size</span>


<span class="c1"># 示例输入
</span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="c1"># 调用函数计算最大全1连通块的大小
</span><span class="n">largest_block_size</span> <span class="o">=</span> <span class="nf">find_largest_ones_block</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">最大全1连通块的大小为:</span><span class="sh">"</span><span class="p">,</span> <span class="n">largest_block_size</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>力扣200：岛屿数量，这题是求连通块的数量，不是最大连通块的大小；https://leetcode.cn/problems/number-of-islands/</li>
  <li>力扣827：最大人工岛，把一个0变成1之后求最大岛屿面积，是本题的进阶版；https://leetcode.cn/problems/making-a-large-island/</li>
  <li>
    <p>力扣695，找到了，是这一题，自解在力扣上是能够通过的，力扣官方题解也并没有提到复杂度更低的算法，可能理想还有其他的解法；https://leetcode.cn/problems/max-area-of-island/</p>
  </li>
  <li>补充知识：深度优先搜索（DFS）</li>
</ul>

<p>DFS（深度优先搜索）是一种用于遍历或搜索图形和树等数据结构的算法。它从一个起始节点开始，沿着路径尽可能深入地探索，直到达到无法继续或者满足特定条件的节点为止，然后回溯并继续探索其他路径。</p>

<ul>
  <li>深度和广度优先搜索(DFS/BFS)</li>
</ul>

<p>DFS（深度优先搜索）和BFS（广度优先搜索）是两种常见的图遍历算法，它们在搜索策略和遍历顺序上有所不同。</p>

<p>搜索策略：</p>

<p>DFS：DFS采用深度优先的搜索策略，即从起始节点开始，沿着路径尽可能深入地探索，直到达到无法继续或满足特定条件的节点为止，然后回溯并继续探索其他路径。DFS通过递归或使用栈来实现。
BFS：BFS采用广度优先的搜索策略，即从起始节点开始，逐层地遍历节点，先访问离起始节点最近的节点，然后依次访问离起始节点逐渐远的节点。BFS使用队列来存储待访问的节点，先进先出的原则确保了按层遍历。</p>

<p>遍历顺序：</p>

<p>DFS：DFS在遍历过程中沿着一个路径尽可能深入，直到达到叶子节点或无法继续探索的节点。因此，DFS的遍历顺序是深度方向上的，先访问最新加入栈的节点。
BFS：BFS在遍历过程中按层遍历，先访问当前层的节点，然后再访问下一层的节点。因此，BFS的遍历顺序是广度方向上的，先访问离起始节点最近的节点。</p>

<ul>
  <li>矩阵可能不能很好的区分深度和广度（事实上上面的题目也可以用两种方法（用栈还是队列存储）），用二叉树就很容易理解区别了</li>
</ul>

<!--![引入图片](/image/leetcode/2023-11-03-lixiang/image_1.jpg) -->]]></content><author><name></name></author><category term="leetcode" /><category term="python" /><category term="js" /><summary type="html"><![CDATA[虽然被捞起来打复活赛，但明显这个部门需要的不是我，选择题基本没有会的，算法两个c的内存调度也没写 只记录两道py]]></summary></entry></feed>